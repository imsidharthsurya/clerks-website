
Cognito.ready('libraryScripts', function($) { var jQuery = $; 
;(function() { if (Cognito.config.scripts.indexOf('cognito-datepicker') >= 0) return; else Cognito.config.scripts.push('cognito-datepicker');/* =========================================================
 * bootstrap-datepicker.js
 * http://www.eyecon.ro/bootstrap-datepicker
 * =========================================================
 * Copyright 2012 Stefan Petre
 * Improvements by Andrew Rowls
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

/* =========================================================
 * Source (?): https://github.com/uxsolutions/bootstrap-datepicker
 * Version (approximately?):
 *   Revision: 511c1b0241eb9804892df6f9388e0afd00107253
 *   Author: Andrew Rowls <andrew@eternicode.com>
 *   Date: 8/18/2013 2:46:30 AM
 *   Message: Merge pull request #223 from alexquast/master
 * ========================================================= */

(function ($) {

	var $window = $(window);

	function UTCDate() {
		return new Date(Date.UTC.apply(Date, arguments));
	}
	function UTCToday() {
		var today = new Date();
		return UTCDate(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate());
	}


	// Picker object

	var Datepicker = function (element, options) {
		var that = this;

		this._process_options(options);

		this.element = $(element);
		this.isInline = false;
		//this.isInput = this.element.is('input');
		this.isInput = true;
		this.component = this.element.parent().parent().find(".c-editor-date-icon:first");
		this.hasInput = false;
		if (this.component && this.component.length === 0)
			this.component = false;

		this.picker = $(DPGlobal.template);
		this._buildEvents();
		this._attachEvents();

		if (this.isInline) {
			this.picker.addClass('cognito-datepicker-inline').appendTo(this.element);
		} else {
			this.picker.addClass('cognito-datepicker-dropdown cognito-dropdown-menu');
		}

		if (this.o.rtl) {
			this.picker.addClass('cognito-datepicker-rtl');
			this.picker.find('.prev i, .next i')
						.toggleClass('icon-arrow-left icon-arrow-right');
		}


		this.viewMode = this.o.startView;

		if (this.o.calendarWeeks)
			this.picker.find('tfoot th.today')
						.attr('colspan', function (i, val) {
							return parseInt(val) + 1;
						});

		this._allow_update = false;

		this.setStartDate(this._o.startDate);
		this.setEndDate(this._o.endDate);
		this.setDaysOfWeekDisabled(this.o.daysOfWeekDisabled);

		this.fillDow();
		this.fillMonths();

		this._allow_update = true;

		this.update();
		this.showMode();

		if (this.isInline) {
			this.show();
		}
	};

	Datepicker.prototype = {
		constructor: Datepicker,

		_process_options: function (opts) {
			// Store raw options for reference
			this._o = $.extend({}, this._o, opts);
			// Processed options
			var o = this.o = $.extend({}, this._o);

			// override the dates variable
			if (opts.dates)
				$.extend(dates, opts.dates);

			// Check if "de-DE" style date is available, if not language should
			// fallback to 2 letter code eg "de"
			var lang = o.language;
			if (!dates[lang]) {
				lang = lang.split('-')[0];
				if (!dates[lang])
					lang = defaults.language;
			}
			o.language = lang;

			switch (o.startView) {
				case 2:
				case 'decade':
					o.startView = 2;
					break;
				case 1:
				case 'year':
					o.startView = 1;
					break;
				default:
					o.startView = 0;
			}

			switch (o.minViewMode) {
				case 1:
				case 'months':
					o.minViewMode = 1;
					break;
				case 2:
				case 'years':
					o.minViewMode = 2;
					break;
				default:
					o.minViewMode = 0;
			}

			o.startView = Math.max(o.startView, o.minViewMode);

			o.weekStart %= 7;
			o.weekEnd = ((o.weekStart + 6) % 7);

			var format = DPGlobal.parseFormat(o.format);
			if (o.startDate !== -Infinity) {
				if (!!o.startDate) {
					if (o.startDate instanceof Date)
						o.startDate = this._local_to_utc(this._zero_time(o.startDate));
					else
						o.startDate = DPGlobal.parseDate(o.startDate, format, o.language);
				} else {
					o.startDate = -Infinity;
				}
			}
			if (o.endDate !== Infinity) {
				if (!!o.endDate) {
					if (o.endDate instanceof Date)
						o.endDate = this._local_to_utc(this._zero_time(o.endDate));
					else
						o.endDate = DPGlobal.parseDate(o.endDate, format, o.language);
				} else {
					o.endDate = Infinity;
				}
			}

			o.daysOfWeekDisabled = o.daysOfWeekDisabled || [];
			if (!$.isArray(o.daysOfWeekDisabled))
				o.daysOfWeekDisabled = o.daysOfWeekDisabled.split(/[,\s]*/);
			o.daysOfWeekDisabled = $.map(o.daysOfWeekDisabled, function (d) {
				return parseInt(d, 10);
			});

			var plc = String(o.orientation).toLowerCase().split(/\s+/g),
				_plc = o.orientation.toLowerCase();
			plc = $.grep(plc, function (word) {
				return (/^auto|left|right|top|bottom$/).test(word);
			});
			o.orientation = { x: 'auto', y: 'auto' };
			if (!_plc || _plc === 'auto')
				; // no action
			else if (plc.length === 1) {
				switch (plc[0]) {
					case 'top':
					case 'bottom':
						o.orientation.y = plc[0];
						break;
					case 'left':
					case 'right':
						o.orientation.x = plc[0];
						break;
				}
			}
			else {
				_plc = $.grep(plc, function (word) {
					return (/^left|right$/).test(word);
				});
				o.orientation.x = _plc[0] || 'auto';

				_plc = $.grep(plc, function (word) {
					return (/^top|bottom$/).test(word);
				});
				o.orientation.y = _plc[0] || 'auto';
			}
		},
		_events: [],
		_secondaryEvents: [],
		_applyEvents: function (evs) {
			for (var i = 0, el, ev; i < evs.length; i++) {
				el = evs[i][0];
				ev = evs[i][1];
				el.on(ev);
			}
		},
		_unapplyEvents: function (evs) {
			for (var i = 0, el, ev; i < evs.length; i++) {
				el = evs[i][0];
				ev = evs[i][1];
				el.off(ev);
			}
		},

		//Toggles the widget open and close
		toggleWidget: function (e) {
			if ($(this.picker).is(":visible"))
				this.hide();
			else {
				this.show();
			}
		},

		_buildEvents: function () {
			if (this.isInput) { // single input
				this._events = [
					[this.element, {
						focus: $.proxy(function (e) {
							if (!this.element.is(".icon-picker-only, .suppress-picker"))
								this.show(e);
						}, this),
						keyup: $.proxy(this.update, this),
						keydown: $.proxy(this.keydown, this)
					}],
					[this.element.parent().parent().find('.c-editor-date-icon'), {
						click: $.proxy(this.toggleWidget, this)
					}]
				];
			}
			else if (this.element.is('div')) {  // inline datepicker
				this.isInline = true;
			}
			else {
				this._events = [
					[this.element, {
						click: $.proxy(this.show, this)
					}]
				];
			}

			this._secondaryEvents = [
				[this.picker, {
					click: $.proxy(this.click, this)
				}],
				[$(window), {
					resize: $.proxy(this.place, this)
				}],
				[$(document), {
					mousedown: $.proxy(function (e) {
						//If the target is not the picker or the date field's widget, icon, or input field, then hide the widget
						if (!(
							this.element.is(e.target) ||
							this.picker.is(e.target) ||
							this.picker.find(e.target).length
						) && (
							//the user is not clicking the editor or icon that belongs to this field
                            !(e.target.className.indexOf("c-editor-date") > -1 ||
                                e.target.className.indexOf("icon-calendar") > -1 ||
                                e.target.className.indexOf("date-icon") > -1 ||
                                this.picker.is(e.target)) ||
                            $(e.target).parents(".c-date-date")[0] !== $(this.element).parents(".c-date-date")[0]
							)
						) {
							this.hide();
						}
					}, this)
				}]
			];
		},
		_attachEvents: function () {
			this._detachEvents();
			this._applyEvents(this._events);
		},
		_detachEvents: function () {
			this._unapplyEvents(this._events);
		},
		_attachSecondaryEvents: function () {
			this._detachSecondaryEvents();
			this._applyEvents(this._secondaryEvents);
		},
		_detachSecondaryEvents: function () {
			this._unapplyEvents(this._secondaryEvents);
		},
		_trigger: function (event, altdate) {
			var date = altdate || this.date,
				local_date = this._utc_to_local(date);

			this.element.trigger({
				type: event,
				date: local_date,
				format: $.proxy(function (altformat) {
					var format = altformat || this.o.format;
					return DPGlobal.formatDate(date, format, this.o.language);
				}, this)
			});
		},

		show: function (e) {
			if ($(this.picker).is(":visible"))
				return;
			if (!this.isInline)
				this.picker.appendTo("body");
			this.picker.show();
			this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();
			this.place();
			this._attachSecondaryEvents();
			if (e) {
                e.preventDefault();                
            }

            if (this.element.val() !== "") {
                this.date = new Date(this.element.val());
                this.update();
            }
            
			this._trigger('show');		
		},

		hide: function (e) {
			if (this.isInline) return;
			if (!this.picker.is(':visible')) return;
			this.picker.hide().detach();
			this._detachSecondaryEvents();
			this.viewMode = this.o.startView;
			this.showMode();

			this._trigger('hide');
		},

		remove: function () {
			this.hide();
			this._detachEvents();
			this._detachSecondaryEvents();
			this.picker.remove();
			delete this.element.data().datepicker;
			if (!this.isInput) {
				delete this.element.data().date;
			}
		},

		_utc_to_local: function (utc) {
			return new Date(utc.getTime() + (utc.getTimezoneOffset() * 60000));
		},
		_local_to_utc: function (local) {
			return new Date(local.getTime() - (local.getTimezoneOffset() * 60000));
		},
		_zero_time: function (local) {
			return new Date(local.getFullYear(), local.getMonth(), local.getDate());
		},
		_zero_utc_time: function (utc) {
			return new Date(Date.UTC(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate()));
		},

		getDate: function () {
			return this._utc_to_local(this.getUTCDate());
		},

		getUTCDate: function () {
			return this.date;
		},

		setDate: function (d) {
			this.setUTCDate(this._local_to_utc(d));
		},

		setUTCDate: function (d) {
			this.date = d;
			this.setValue();
		},

		setValue: function () {
			var formatted = this.getFormattedDate();
            if (!this.isInput) {
				if (this.component) {
                    this.element.find('input').val(formatted).change();
				}
			} else {
				this.element.val(formatted).change();
			}
		},

		getFormattedDate: function (format) {
			if (format === undefined)
				format = this.o.format;
			return DPGlobal.formatDate(this.date, format, this.o.language);
		},

		setStartDate: function (startDate) {
			this._process_options({ startDate: startDate });
			this.update();
			this.updateNavArrows();
		},

		setEndDate: function (endDate) {
			this._process_options({ endDate: endDate });
			this.update();
			this.updateNavArrows();
		},

		setDaysOfWeekDisabled: function (daysOfWeekDisabled) {
			this._process_options({ daysOfWeekDisabled: daysOfWeekDisabled });
			this.update();
			this.updateNavArrows();
		},

		place: function () {
			if (this.isInline) return;
			var calendarWidth = this.picker.outerWidth(),
				calendarHeight = this.picker.outerHeight(),
				visualPadding = 10,
				windowWidth = $window.width(),
				windowHeight = $window.height(),
				scrollTop = $window.scrollTop();

			var zIndex = parseInt(this.element.parents().filter(function () {
				return $(this).css('z-index') != 'auto';
			}).first().css('z-index')) + 10;
			var offset = this.element.offset();
			var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(false);
			var width = this.component ? this.component.outerWidth(true) : this.element.outerWidth(false);
			var left = offset.left,
				top = offset.top;

			this.picker.removeClass(
				'cognito-datepicker-orient-top cognito-datepicker-orient-bottom ' +
				'cognito-datepicker-orient-right cognito-datepicker-orient-left ' +
                'cognito-datepicker-center-arrow'
			);

			if (this.o.orientation.x !== 'auto') {
				this.picker.addClass('cognito-datepicker-orient-' + this.o.orientation.x);
				if (this.o.orientation.x === 'right')
					left -= calendarWidth - width;
			}
            // auto x orientation is best-placement: if it crosses a window
            // edge, fudge it sideways
			else {
				// Default to left
				this.picker.addClass('cognito-datepicker-orient-left');
				if (offset.left < 0)
					left -= offset.left - visualPadding;
				else if (offset.left + calendarWidth > windowWidth)
					left = windowWidth - calendarWidth - visualPadding;
			}

			if (left + calendarWidth + visualPadding >= windowWidth)
			    this.picker.addClass('cognito-datepicker-center-arrow');

			// auto y orientation is best-situation: top or bottom, no fudging,
			// decision based on which shows more of the calendar
			var yorient = this.o.orientation.y,
				top_overflow, bottom_overflow;
			if (yorient === 'auto') {
				top_overflow = -scrollTop + offset.top - calendarHeight;
				bottom_overflow = scrollTop + windowHeight - (offset.top + height + calendarHeight);
				if (Math.max(top_overflow, bottom_overflow) === bottom_overflow)
					yorient = 'top';
				else
					yorient = 'bottom';
			}
			this.picker.addClass('cognito-datepicker-orient-' + yorient);
			if (yorient === 'top')
				top += height + 6;
			else
				top -= calendarHeight + parseInt(this.picker.css('padding-top'));

			this.picker.css({
				top: top,
				left: left,
				zIndex: zIndex
			});
		},

		_allow_update: true,
		update: function () {
			if (!this._allow_update) return;

			var oldDate = new Date(this.date),
				date, fromArgs = false;
			if (arguments && arguments.length && (typeof arguments[0] === 'string' || arguments[0] instanceof Date)) {
				date = arguments[0];
				if (date instanceof Date)
					date = this._local_to_utc(date);
				fromArgs = true;
			} else {
				date = this.isInput ? this.element.val() : this.element.data('date') || this.element.find('input').val();
				delete this.element.data().date;
			}

			this.date = DPGlobal.parseDate(date, this.o.format, this.o.language);

			// setting date by clicking?
			if (fromArgs) this.setValue();

			if (this.date < this.o.startDate) {
				this.viewDate = new Date(this.o.startDate);
				this.date = new Date(this.o.startDate);
			} else if (this.date > this.o.endDate) {
				this.viewDate = new Date(this.o.endDate);
				this.date = new Date(this.o.endDate);
			} else {
				this.viewDate = new Date(this.date);
				this.date = new Date(this.date);
			}
			this.fill();
            var keys = [
                "37",	// left
                "38",	// up
                "39",	// right
                "40"	// down
            ];

            if (arguments && arguments.length && keys.indexOf(arguments[0].keyCode) !== -1)
                arguments[0].stopPropagation();
		},

		fillDow: function () {
			var dowCnt = this.o.weekStart,
			html = '<tr>';
			if (this.o.calendarWeeks) {
				var cell = '<th class="cw">&nbsp;</th>';
				html += cell;
				this.picker.find('.cognito-datepicker-days thead tr:first-child').prepend(cell);
			}
			while (dowCnt < this.o.weekStart + 7) {
				html += '<th class="dow">' + dates[this.o.language].daysMin[(dowCnt++) % 7] + '</th>';
			}
			html += '</tr>';
			this.picker.find('.cognito-datepicker-days thead').append(html);
		},

		fillMonths: function () {
			var html = '',
			i = 0;
			while (i < 12) {
				html += '<span class="month">' + dates[this.o.language].monthsShort[i++] + '</span>';
			}
			this.picker.find('.cognito-datepicker-months td').html(html);
		},

		setRange: function (range) {
			if (!range || !range.length)
				delete this.range;
			else
				this.range = $.map(range, function (d) { return d.valueOf(); });
			this.fill();
		},

		getClassNames: function (date) {
			var cls = [],
				year = this.viewDate.getUTCFullYear(),
				month = this.viewDate.getUTCMonth(),
				currentDate = this.date.valueOf(),
				today = new Date();
			if (date.getUTCFullYear() < year || (date.getUTCFullYear() == year && date.getUTCMonth() < month)) {
				cls.push('old');
			} else if (date.getUTCFullYear() > year || (date.getUTCFullYear() == year && date.getUTCMonth() > month)) {
				cls.push('new');
			}
			// Compare internal UTC date with local today, not UTC today
			if (this.o.todayHighlight &&
				date.getUTCFullYear() == today.getFullYear() &&
				date.getUTCMonth() == today.getMonth() &&
				date.getUTCDate() == today.getDate()) {
				cls.push('today');
			}
			if (currentDate && date.valueOf() == currentDate) {
				cls.push('active');
			}
			if (date.valueOf() < this.o.startDate || date.valueOf() > this.o.endDate ||
				$.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1) {
				cls.push('disabled');
			}
			if (this.range) {
				if (date > this.range[0] && date < this.range[this.range.length - 1]) {
					cls.push('range');
				}
				if ($.inArray(date.valueOf(), this.range) != -1) {
					cls.push('selected');
				}
			}
			return cls;
		},

		fill: function () {
			var d = new Date(this.viewDate),
				year = d.getUTCFullYear(),
				month = d.getUTCMonth(),
				startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
				startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
				endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
				endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
				currentDate = this.date && this.date.valueOf(),
				tooltip;
			this.picker.find('.cognito-datepicker-days thead th.datepicker-switch')
						.text(dates[this.o.language].months[month] + ' ' + year);
			this.picker.find('tfoot th.today')
						.text(dates[this.o.language].today)
						.toggle(this.o.todayBtn !== false);
			this.picker.find('tfoot th.clear')
						.text(dates[this.o.language].clear)
						.toggle(this.o.clearBtn !== false);
			this.updateNavArrows();
			this.fillMonths();
			var prevMonth = UTCDate(year, month - 1, 28, 0, 0, 0, 0),
				day = DPGlobal.getDaysInMonth(prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());
			prevMonth.setUTCDate(day);
			prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7) % 7);
			var nextMonth = new Date(prevMonth);
			nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
			nextMonth = nextMonth.valueOf();
			var html = [];
			var clsName;
			while (prevMonth.valueOf() < nextMonth) {
				if (prevMonth.getUTCDay() == this.o.weekStart) {
					html.push('<tr>');
					if (this.o.calendarWeeks) {
						// ISO 8601: First week contains first thursday.
						// ISO also states week starts on Monday, but we can be more abstract here.
						var
							// Start of current week: based on weekstart/current date
							ws = new Date(+prevMonth + (this.o.weekStart - prevMonth.getUTCDay() - 7) % 7 * 864e5),
							// Thursday of this week
							th = new Date(+ws + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),
							// First Thursday of year, year from thursday
							yth = new Date(+(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay()) % 7 * 864e5),
							// Calendar week: ms between thursdays, div ms per day, div 7 days
							calWeek = (th - yth) / 864e5 / 7 + 1;
						html.push('<td class="cw">' + calWeek + '</td>');

					}
				}
				clsName = this.getClassNames(prevMonth);
				clsName.push('day');

				if (this.o.beforeShowDay !== $.noop) {
					var before = this.o.beforeShowDay(this._utc_to_local(prevMonth));
					if (before === undefined)
						before = {};
					else if (typeof (before) === 'boolean')
						before = { enabled: before };
					else if (typeof (before) === 'string')
						before = { classes: before };
					if (before.enabled === false)
						clsName.push('disabled');
					if (before.classes)
						clsName = clsName.concat(before.classes.split(/\s+/));
					if (before.tooltip)
						tooltip = before.tooltip;
				}

				clsName = $.unique(clsName);
				html.push('<td class="' + clsName.join(' ') + '"' + (tooltip ? ' title="' + tooltip + '"' : '') + '>' + prevMonth.getUTCDate() + '</td>');
				if (prevMonth.getUTCDay() == this.o.weekEnd) {
					html.push('</tr>');
				}
				prevMonth.setUTCDate(prevMonth.getUTCDate() + 1);
			}
			this.picker.find('.cognito-datepicker-days tbody').empty().append(html.join(''));
			var currentYear = this.date && this.date.getUTCFullYear();

			var months = this.picker.find('.cognito-datepicker-months')
						.find('th:eq(1)')
							.text(year)
							.end()
						.find('span').removeClass('active');
			if (currentYear && currentYear == year) {
				months.eq(this.date.getUTCMonth()).addClass('active');
			}
			if (year < startYear || year > endYear) {
				months.addClass('disabled');
			}
			if (year == startYear) {
				months.slice(0, startMonth).addClass('disabled');
			}
			if (year == endYear) {
				months.slice(endMonth + 1).addClass('disabled');
			}

			html = '';
			year = parseInt(year / 10, 10) * 10;
			var yearCont = this.picker.find('.cognito-datepicker-years')
								.find('th:eq(1)')
									.text(year + '-' + (year + 9))
									.end()
								.find('td');
			year -= 1;
			for (var i = -1; i < 11; i++) {
				html += '<span class="year' + (i == -1 ? ' old' : i == 10 ? ' new' : '') + (currentYear == year ? ' active' : '') + (year < startYear || year > endYear ? ' disabled' : '') + '">' + year + '</span>';
				year += 1;
			}
			yearCont.html(html);
		},

		updateNavArrows: function () {
			if (!this._allow_update) return;

			var d = new Date(this.viewDate),
				year = d.getUTCFullYear(),
				month = d.getUTCMonth();
			switch (this.viewMode) {
				case 0:
					if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear() && month <= this.o.startDate.getUTCMonth()) {
						this.picker.find('.prev').css({ visibility: 'hidden' });
					} else {
						this.picker.find('.prev').css({ visibility: 'visible' });
					}
					if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear() && month >= this.o.endDate.getUTCMonth()) {
						this.picker.find('.next').css({ visibility: 'hidden' });
					} else {
						this.picker.find('.next').css({ visibility: 'visible' });
					}
					break;
				case 1:
				case 2:
					if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear()) {
						this.picker.find('.prev').css({ visibility: 'hidden' });
					} else {
						this.picker.find('.prev').css({ visibility: 'visible' });
					}
					if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear()) {
						this.picker.find('.next').css({ visibility: 'hidden' });
					} else {
						this.picker.find('.next').css({ visibility: 'visible' });
					}
					break;
			}
		},

		click: function (e) {
			e.preventDefault();
			var target = $(e.target).closest('span, td, th');
			if (target.length == 1) {
				switch (target[0].nodeName.toLowerCase()) {
					case 'th':
						switch (target[0].className) {
							case 'datepicker-switch':
								this.showMode(1);
								break;
							case 'prev':
							case 'next':
								var dir = DPGlobal.modes[this.viewMode].navStep * (target[0].className == 'prev' ? -1 : 1);
								switch (this.viewMode) {
									case 0:
										this.viewDate = this.moveMonth(this.viewDate, dir);
										this._trigger('changeMonth', this.viewDate);
										break;
									case 1:
									case 2:
										this.viewDate = this.moveYear(this.viewDate, dir);
										if (this.viewMode === 1)
											this._trigger('changeYear', this.viewDate);
										break;
								}
								this.fill();
								break;
							case 'today':
								var date = new Date();
								date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);

								this.showMode(-2);
								var which = this.o.todayBtn == 'linked' ? null : 'view';
								this._setDate(date, which);
								break;
							case 'clear':
								var element;
								if (this.isInput)
									element = this.element;
								else if (this.component)
									element = this.element.find('input');
								if (element)
									element.val("").change();
								this._trigger('changeDate');
								this.update();
								if (this.o.autoclose)
									this.hide();
								break;
						}
						break;
					case 'span':
						if (!target.is('.disabled')) {
							this.viewDate.setUTCDate(1);
							if (target.is('.month')) {
								var day = 1;
								var month = target.parent().find('span').index(target);
								var year = this.viewDate.getUTCFullYear();
								this.viewDate.setUTCMonth(month);
								this._trigger('changeMonth', this.viewDate);
								if (this.o.minViewMode === 1) {
									this._setDate(UTCDate(year, month, day, 0, 0, 0, 0));
								}
							} else {
								var year = parseInt(target.text(), 10) || 0;
								var day = 1;
								var month = 0;
								this.viewDate.setUTCFullYear(year);
								this._trigger('changeYear', this.viewDate);
								if (this.o.minViewMode === 2) {
									this._setDate(UTCDate(year, month, day, 0, 0, 0, 0));
								}
							}
							this.showMode(-1);
							this.fill();
						}
						break;
					case 'td':
						if (target.is('.day') && !target.is('.disabled')) {
							var day = parseInt(target.text(), 10) || 1;
							var year = this.viewDate.getUTCFullYear(),
								month = this.viewDate.getUTCMonth();
							if (target.is('.old')) {
								if (month === 0) {
									month = 11;
									year -= 1;
								} else {
									month -= 1;
								}
							} else if (target.is('.new')) {
								if (month == 11) {
									month = 0;
									year += 1;
								} else {
									month += 1;
								}
							}
							this._setDate(UTCDate(year, month, day, 0, 0, 0, 0));
						}
						break;
				}
			}
		},

		_setDate: function (date, which) {
			if (!which || which == 'date')
				this.date = new Date(date);
			if (!which || which == 'view')
				this.viewDate = new Date(date);
			this.fill();
			this.setValue();
			this._trigger('changeDate');
			var element;
			if (this.isInput) {
				element = this.element;
			} else if (this.component) {
				element = this.element.find('input');
			}
			if (element) {
				element.change();
			}
			if (this.o.autoclose && (!which || which == 'date')) {
				this.hide();
			}
		},

		moveMonth: function (date, dir) {
			if (!dir) return date;
			var new_date = new Date(date.valueOf()),
				day = new_date.getUTCDate(),
				month = new_date.getUTCMonth(),
				mag = Math.abs(dir),
				new_month, test;
			dir = dir > 0 ? 1 : -1;
			if (mag == 1) {
				test = dir == -1
					// If going back one month, make sure month is not current month
					// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
					? function () { return new_date.getUTCMonth() == month; }
					// If going forward one month, make sure month is as expected
					// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
					: function () { return new_date.getUTCMonth() != new_month; };
				new_month = month + dir;
				new_date.setUTCMonth(new_month);
				// Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11
				if (new_month < 0 || new_month > 11)
					new_month = (new_month + 12) % 12;
			} else {
				// For magnitudes >1, move one month at a time...
				for (var i = 0; i < mag; i++)
					// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
					new_date = this.moveMonth(new_date, dir);
				// ...then reset the day, keeping it in the new month
				new_month = new_date.getUTCMonth();
				new_date.setUTCDate(day);
				test = function () { return new_month != new_date.getUTCMonth(); };
			}
			// Common date-resetting loop -- if date is beyond end of month, make it
			// end of month
			while (test()) {
				new_date.setUTCDate(--day);
				new_date.setUTCMonth(new_month);
			}
			return new_date;
		},

		moveYear: function (date, dir) {
			return this.moveMonth(date, dir * 12);
		},

		dateWithinRange: function (date) {
			return date >= this.o.startDate && date <= this.o.endDate;
		},

		keydown: function (e) {
			if (this.picker.is(':not(:visible)')) {
				// allow escape/alt+down to hide and re-show picker
				if (e.keyCode == 27 || (e.altKey && e.keyCode === 40)) {
					this.show(e);
					e.stopPropagation();
				}
				return;
			}
			else if (e.altKey && e.keyCode === 38) {
				e.preventDefault();
				e.stopPropagation();
				this.hide();
				return;
			}

			var dateChanged = false,
				dir, day, month,
				newDate, newViewDate;
			switch (e.keyCode) {
				case 27: // escape
					this.hide();
					e.preventDefault();
					break;
				case 37: // left
				case 39: // right
					if (!this.o.keyboardNavigation) break;
					dir = e.keyCode == 37 ? -1 : 1;
					if (e.ctrlKey) {
						newDate = this.moveYear(this.date, dir);
						newViewDate = this.moveYear(this.viewDate, dir);
						this._trigger('changeYear', this.viewDate);
					} else if (e.shiftKey) {
						newDate = this.moveMonth(this.date, dir);
						newViewDate = this.moveMonth(this.viewDate, dir);
						this._trigger('changeMonth', this.viewDate);
					} else {
						newDate = new Date(this.date);
						newDate.setUTCDate(this.date.getUTCDate() + dir);
						newViewDate = new Date(this.viewDate);
						newViewDate.setUTCDate(this.viewDate.getUTCDate() + dir);
					}
					if (this.dateWithinRange(newDate)) {
						this.date = newDate;
						this.viewDate = newViewDate;
						this.setValue();
						this.update();
						e.preventDefault();
						dateChanged = true;
					}
					e.stopPropagation();
					break;
				case 38: // up
				case 40: // down
					if (!this.o.keyboardNavigation) break;
					dir = e.keyCode == 38 ? -1 : 1;
					if (e.ctrlKey) {
						newDate = this.moveYear(this.date, dir);
						newViewDate = this.moveYear(this.viewDate, dir);
						this._trigger('changeYear', this.viewDate);
					} else if (e.shiftKey) {
						newDate = this.moveMonth(this.date, dir);
						newViewDate = this.moveMonth(this.viewDate, dir);
						this._trigger('changeMonth', this.viewDate);
					}
					else {
						newDate = new Date(this.date);
						newDate.setUTCDate(this.date.getUTCDate() + dir * 7);
						newViewDate = new Date(this.viewDate);
						newViewDate.setUTCDate(this.viewDate.getUTCDate() + dir * 7);
					}
					if (this.dateWithinRange(newDate)) {
						this.date = newDate;
						this.viewDate = newViewDate;
						this.setValue();
						this.update();
						e.preventDefault();
						dateChanged = true;
					}
					e.stopPropagation();
					break;
				case 13: // enter
					// Capture value before setting to see if the date changed
					var originalElementValue = this.element.val();
					this.setValue();
					// Update the dateChanged variable so that "changeDate" event is raised appropriately
					var newElementValue = this.element.val();
					if (newElementValue && newElementValue !== originalElementValue) {
						dateChanged = true;
					}
					this.hide();
					e.preventDefault();
					e.stopPropagation();
					break;
				case 9: // tab
					this.hide();
					break;
			}
			if (dateChanged) {
				this._trigger('changeDate');
				var element;
				if (this.isInput) {
					element = this.element;
				} else if (this.component) {
					element = this.element.find('input');
				}
				if (element) {
					element.change();
				}
			}
		},

		showMode: function (dir) {
			if (dir) {
				this.viewMode = Math.max(this.o.minViewMode, Math.min(2, this.viewMode + dir));
			}
			/*
				vitalets: fixing bug of very special conditions:
				jquery 1.7.1 + webkit + show inline datepicker in bootstrap popover.
				Method show() does not set display css correctly and datepicker is not shown.
				Changed to .css('display', 'block') solve the problem.
				See https://github.com/vitalets/x-editable/issues/37

				In jquery 1.7.2+ everything works fine.
			*/
			//this.picker.find('>div').hide().filter('.datepicker-'+DPGlobal.modes[this.viewMode].clsName).show();
			this.picker.find('>div').hide().filter('.cognito-datepicker-' + DPGlobal.modes[this.viewMode].clsName).css('display', 'block');
			this.updateNavArrows();
		}
	};

	var DateRangePicker = function (element, options) {
		this.element = $(element);
		this.inputs = $.map(options.inputs, function (i) { return i.jquery ? i[0] : i; });
		delete options.inputs;

		$(this.inputs)
			.datepicker(options)
			.bind('changeDate', $.proxy(this.dateUpdated, this));

		this.pickers = $.map(this.inputs, function (i) { return $(i).data('datepicker'); });
		this.updateDates();
	};
	DateRangePicker.prototype = {
		updateDates: function () {
			this.dates = $.map(this.pickers, function (i) { return i.date; });
			this.updateRanges();
		},
		updateRanges: function () {
			var range = $.map(this.dates, function (d) { return d.valueOf(); });
			$.each(this.pickers, function (i, p) {
				p.setRange(range);
			});
		},
		dateUpdated: function (e) {
			var dp = $(e.target).data('datepicker'),
				new_date = dp.getUTCDate(),
				i = $.inArray(e.target, this.inputs),
				l = this.inputs.length;
			if (i == -1) return;

			if (new_date < this.dates[i]) {
				// Date being moved earlier/left
				while (i >= 0 && new_date < this.dates[i]) {
					this.pickers[i--].setUTCDate(new_date);
				}
			}
			else if (new_date > this.dates[i]) {
				// Date being moved later/right
				while (i < l && new_date > this.dates[i]) {
					this.pickers[i++].setUTCDate(new_date);
				}
			}
			this.updateDates();
		},
		remove: function () {
			$.map(this.pickers, function (p) { p.remove(); });
			delete this.element.data().datepicker;
		}
	};

	function opts_from_el(el, prefix) {
		// Derive options from element data-attrs
		var data = $(el).data(),
			out = {}, inkey,
			replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])'),
			prefix = new RegExp('^' + prefix.toLowerCase());
		for (var key in data)
			if (prefix.test(key)) {
				inkey = key.replace(replace, function (_, a) { return a.toLowerCase(); });
				out[inkey] = data[key];
			}
		return out;
	}

	function opts_from_locale(lang) {
		// Derive options from locale plugins
		var out = {};
		// Check if "de-DE" style date is available, if not language should
		// fallback to 2 letter code eg "de"
		if (!dates[lang]) {
			lang = lang.split('-')[0]
			if (!dates[lang])
				return;
		}
		var d = dates[lang];
		$.each(locale_opts, function (i, k) {
			if (k in d)
				out[k] = d[k];
		});
		return out;
	}

	var old = $.fn.datepicker;
	$.fn.datepicker = function (option) {
		var args = Array.apply(null, arguments);
		args.shift();
		var internal_return,
			this_return;
		this.each(function () {
			var $this = $(this),
				data = $this.data('datepicker'),
				options = typeof option == 'object' && option;
			if (!data) {
				var elopts = opts_from_el(this, 'date'),
					// Preliminary otions
					xopts = $.extend({}, defaults, elopts, options),
					locopts = opts_from_locale(xopts.language),
					// Options priority: js args, data-attrs, locales, defaults
					opts = $.extend({}, defaults, locopts, options, elopts);
				if ($this.is('.input-daterange') || opts.inputs) {
					var ropts = {
						inputs: opts.inputs || $this.find('input').toArray()
					};
					$this.data('datepicker', (data = new DateRangePicker(this, $.extend(opts, ropts))));
				}
				else {
					$this.data('datepicker', (data = new Datepicker(this, opts)));
				}
			}
			if (typeof option == 'string' && typeof data[option] == 'function') {
				internal_return = data[option].apply(data, args);
				if (internal_return !== undefined)
					return false;
			}
		});
		if (internal_return !== undefined)
			return internal_return;
		else
			return this;
	};

	var defaults = $.fn.datepicker.defaults = {
		autoclose: true,
		beforeShowDay: $.noop,
		calendarWeeks: false,
		clearBtn: false,
		daysOfWeekDisabled: [],
		endDate: Infinity,
		forceParse: true,
		format: 'mm/dd/yyyy',
		keyboardNavigation: true,
		language: 'en',
		minViewMode: 0,
		orientation: "auto",
		rtl: false,
		startDate: -Infinity,
		startView: 0,
		todayBtn: false,
		todayHighlight: false,
		weekStart: 0
	};
	var locale_opts = $.fn.datepicker.locale_opts = [
		'format',
		'rtl',
		'weekStart'
	];
	$.fn.datepicker.Constructor = Datepicker;
	var dates = $.fn.datepicker.dates = {
		en: {
			days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
			daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
			daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
			months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
			monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
			today: "Today",
			clear: "Clear"
		}
	};

	var DPGlobal = {
		modes: [
			{
				clsName: 'days',
				navFnc: 'Month',
				navStep: 1
			},
			{
				clsName: 'months',
				navFnc: 'FullYear',
				navStep: 1
			},
			{
				clsName: 'years',
				navFnc: 'FullYear',
				navStep: 10
			}],
		isLeapYear: function (year) {
			return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));
		},
		getDaysInMonth: function (year, month) {
			return [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
		},
		validParts: /dd?|DD?|mmm|mm?|MM?|yy(?:yy)?/g,
		nonpunctuation: /[^ -\/:-@\[\u3400-\u9fff-`{-~\t\n\r]+/g,
		parseFormat: function (format) {
			// IE treats \0 as a string end in inputs (truncating the value),
			// so it's a bad format delimiter, anyway
			var separators = format.replace(this.validParts, '\0').split('\0'),
				parts = format.match(this.validParts);
			if (!separators || !separators.length || !parts || parts.length === 0) {
				throw new Error("Invalid date format.");
			}
			return { separators: separators, parts: parts };
		},
		parseDate: function (date, format, language) {
			if (date instanceof Date) return date;
			if (typeof format === 'string')
				format = DPGlobal.parseFormat(format);
			if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/.test(date)) {
				var part_re = /([\-+]\d+)([dmwy])/,
					parts = date.match(/([\-+]\d+)([dmwy])/g),
					part, dir;
				date = new Date();
				for (var i = 0; i < parts.length; i++) {
					part = part_re.exec(parts[i]);
					dir = parseInt(part[1]);
					switch (part[2]) {
						case 'd':
							date.setUTCDate(date.getUTCDate() + dir);
							break;
						case 'm':
							date = Datepicker.prototype.moveMonth.call(Datepicker.prototype, date, dir);
							break;
						case 'w':
							date.setUTCDate(date.getUTCDate() + dir * 7);
							break;
						case 'y':
							date = Datepicker.prototype.moveYear.call(Datepicker.prototype, date, dir);
							break;
					}
				}
				return UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);
			}
			var parts = date && date.match(this.nonpunctuation) || [],
				date = new Date(),
				parsed = {},
				setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
				setters_map = {
					yyyy: function (d, v) { return d.setUTCFullYear(v); },
					yy: function (d, v) { return d.setUTCFullYear(2000 + v); },
					m: function (d, v) {
						if (isNaN(d))
							return d;
						v -= 1;
						while (v < 0) v += 12;
						v %= 12;
						d.setUTCMonth(v);
						while (d.getUTCMonth() != v)
							d.setUTCDate(d.getUTCDate() - 1);
						return d;
					},
					d: function (d, v) { return d.setUTCDate(v); }
				},
				val, filtered, part;
			setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
			setters_map['dd'] = setters_map['d'];
			date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
			var fparts = format.parts.slice();
			// Remove noop parts
			if (parts.length != fparts.length) {
				fparts = $(fparts).filter(function (i, p) {
					return $.inArray(p, setters_order) !== -1;
				}).toArray();
			}
			// Process remainder
			if (parts.length == fparts.length) {
				for (var i = 0, cnt = fparts.length; i < cnt; i++) {
					val = parseInt(parts[i], 10);
					part = fparts[i];
					if (isNaN(val)) {
						switch (part) {
							case 'MM':
								filtered = $(dates[language].months).filter(function () {
									var m = this.slice(0, parts[i].length),
										p = parts[i].slice(0, m.length);
									return m == p;
								});
								val = $.inArray(filtered[0], dates[language].months) + 1;
								break;
							case 'M':
								filtered = $(dates[language].monthsShort).filter(function () {
									var m = this.slice(0, parts[i].length),
										p = parts[i].slice(0, m.length);
									return m == p;
								});
								val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
								break;
						}
					}
					parsed[part] = val;
				}
				for (var i = 0, _date, s; i < setters_order.length; i++) {
					s = setters_order[i];
					if (s in parsed && !isNaN(parsed[s])) {
						_date = new Date(date);
						setters_map[s](_date, parsed[s]);
						if (!isNaN(_date))
							date = _date;
					}
				}
			}
			return date;
		},
		formatDate: function (date, format, language) {
			if (typeof format === 'string')
				format = DPGlobal.parseFormat(format);
			var val = {
				d: date.getUTCDate(),
				D: dates[language].daysShort[date.getUTCDay()],
				DD: dates[language].days[date.getUTCDay()],
				m: date.getUTCMonth() + 1,
				mmm: dates[language].monthsShort[date.getUTCMonth()],
				M: dates[language].monthsShort[date.getUTCMonth()],
				MM: dates[language].months[date.getUTCMonth()],
				yy: date.getUTCFullYear().toString().substring(2),
				yyyy: date.getUTCFullYear()
			};
			val.dd = (val.d < 10 ? '0' : '') + val.d;
			val.mm = (val.m < 10 ? '0' : '') + val.m;
			var date = [],
				seps = $.extend([], format.separators);
			for (var i = 0, cnt = format.parts.length; i <= cnt; i++) {
				if (seps.length)
					date.push(seps.shift());
				date.push(val[format.parts[i]]);
			}
			return date.join('');
		},
		headTemplate: '<thead>' +
							'<tr>' +
								'<th class="prev">&laquo;</th>' +
								'<th colspan="5" class="datepicker-switch"></th>' +
								'<th class="next">&raquo;</th>' +
							'</tr>' +
						'</thead>',
		contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
		footTemplate: '<tfoot><tr><th colspan="7" class="today"></th></tr><tr><th colspan="7" class="clear"></th></tr></tfoot>'
	};
	DPGlobal.template = '<div class="cognito-datepicker">' +
							'<div class="cognito-datepicker-days">' +
								'<table class=" table-condensed">' +
									DPGlobal.headTemplate +
									'<tbody></tbody>' +
									DPGlobal.footTemplate +
								'</table>' +
							'</div>' +
							'<div class="cognito-datepicker-months">' +
								'<table class="table-condensed">' +
									DPGlobal.headTemplate +
									DPGlobal.contTemplate +
									DPGlobal.footTemplate +
								'</table>' +
							'</div>' +
							'<div class="cognito-datepicker-years">' +
								'<table class="table-condensed">' +
									DPGlobal.headTemplate +
									DPGlobal.contTemplate +
									DPGlobal.footTemplate +
								'</table>' +
							'</div>' +
						'</div>';

	$.fn.datepicker.DPGlobal = DPGlobal;


	/* DATEPICKER NO CONFLICT
	* =================== */

	$.fn.datepicker.noConflict = function () {
		$.fn.datepicker = old;
		return this;
	};


	/* DATEPICKER DATA-API
	* ================== */

	$(document).on(
		'focus.datepicker.data-api click.datepicker.data-api',
		'[data-provide="datepicker"]',
		function (e) {
			var $this = $(this);
			if ($this.data('datepicker')) return;
			e.preventDefault();
			// component click requires us to explicitly show it
			$this.datepicker('show');
		}
	);
	$(function () {
		$('[data-provide="datepicker-inline"]').datepicker();
	});

}(jQuery));
})();
;(function() { if (Cognito.config.scripts.indexOf('cognito-timepicker') >= 0) return; else Cognito.config.scripts.push('cognito-timepicker');/*!
 * Timepicker Component for Twitter Bootstrap
 *
 * Copyright 2013 Joris de Wit
 *
 * Contributors https://github.com/jdewit/bootstrap-timepicker/graphs/contributors
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
(function ($, window, document, undefined) {
	'use strict';

	// TIMEPICKER PUBLIC CLASS DEFINITION
	var Timepicker = function (element, options) {
		this.widget = '';
		this.$element = $(element);
		this.defaultTime = options.defaultTime;
		this.disableFocus = options.disableFocus;
		this.isOpen = options.isOpen;
		this.minuteStep = options.minuteStep;
		this.modalBackdrop = options.modalBackdrop;
		this.secondStep = options.secondStep;
		this.showInputs = options.showInputs;
		this.showMeridian = options.showMeridian;
		this.timeSeparator = options.timeSeparator;
		if (this.showMeridian)
		{
			this.AMDesignator = options.AMDesignator;
			this.PMDesignator = options.PMDesignator;
		}
		this.showSeconds = options.showSeconds;
		this.template = options.template;
		this.appendWidgetTo = options.appendWidgetTo;
		this.twoDigitHourFormat = options.twoDigitHourFormat;

		this._init();
	};

	Timepicker.prototype = {

		constructor: Timepicker,

		_init: function () {
			var self = this;

			if (this.$element.parent().hasClass('c-editor-time')) {
				this.$element.parent('.c-editor-time').parent().find('.c-editor-time-icon').on({
					'click.timepicker': $.proxy(this.toggleWidget, this)
				});
				this.$element.on({
					'focus.timepicker': $.proxy(function (e) {
						if (!this.$element.is(".icon-picker-only, .suppress-picker"))
							this.showOrHighlight(e);
					}, this),
					'click.timepicker': $.proxy(function (e) {
						if (!this.$element.is(".icon-picker-only"))
							this.showOrHighlight(e);
					}, this),
					'keydown.timepicker': $.proxy(this.elementKeydown, this),
					'blur.timepicker': $.proxy(this.blurElement, this)
				});
			} else {
				if (this.template) {
					this.$element.on({
						'focus.timepicker': $.proxy(this.toggleWidget, this),
						'click.timepicker': $.proxy(this.toggleWidget, this),
						'blur.timepicker': $.proxy(this.blurElement, this)
					});
				} else {
					this.$element.on({
						'focus.timepicker': $.proxy(this.showOrHighlight, this),
						'click.timepicker': $.proxy(this.showOrHighlight, this),
						'keydown.timepicker': $.proxy(this.elementKeydown, this),
						'blur.timepicker': $.proxy(this.blurElement, this)
					});
				}
			}

			if (this.template !== false) {
				//this.$widget = $(this.getTemplate()).prependTo(this.$element.parents(this.appendWidgetTo)).on('click', $.proxy(this.widgetClick, this));
				this.$widget = $(this.getTemplate()).appendTo('body').on('click', $.proxy(this.widgetClick, this));
			} else {
				this.$widget = false;
			}

			if (this.showInputs && this.$widget !== false) {
				this.$widget.find('input').each(function () {
					$(this).on({
						'click.timepicker': function () { $(this).select(); },
						'keydown.timepicker': $.proxy(self.widgetKeydown, self)
					});
				});
			}

			this.setDefaultTime(this.defaultTime);
		},

		blurElement: function () {
			this.highlightedUnit = undefined;
			this.updateFromElementVal();
		},

		decrementHour: function () {
			if (this.showMeridian) {
				if (this.hour === 1) {
					this.hour = 12;
				} else if (this.hour === 12) {
					this.hour--;

					return this.toggleMeridian();
				} else if (this.hour === 0) {
					this.hour = 11;

					return this.toggleMeridian();
				} else {
					this.hour--;
				}
			} else {
				if (this.hour === 0) {
					this.hour = 23;
				} else {
					this.hour--;
				}
			}
			this.update();
		},

		decrementMinute: function (step) {
			var newVal;

			if (step) {
				newVal = this.minute - step;
			} else {
				newVal = this.minute - this.minuteStep;
			}

			if (newVal < 0) {
				this.decrementHour();
				this.minute = newVal + 60;
			} else {
				this.minute = newVal;
			}
			this.update();
		},

		decrementSecond: function () {
			var newVal = this.second - this.secondStep;

			if (newVal < 0) {
				this.decrementMinute(true);
				this.second = newVal + 60;
			} else {
				this.second = newVal;
			}
			this.update();
		},

		elementKeydown: function (e) {
			switch (e.keyCode) {
				case 9: //tab
					this.updateFromElementVal();

					if (!this.$element.val()) {
						this.hideWidget();
					}
					else if (e.shiftKey) {
						if (this.highlightedUnit === "hour")
							this.hideWidget();
						else {
							e.preventDefault();
							this.highlightPrevUnit();
						}
					}
					else {
						switch (this.highlightedUnit) {
							case 'hour':
								e.preventDefault();
								this.highlightNextUnit();
								break;
							case 'minute':
								if (this.showMeridian || this.showSeconds) {
									e.preventDefault();
									this.highlightNextUnit();
								}
								else
									this.hideWidget();
								break;
							case 'second':
								if (this.showMeridian) {
									e.preventDefault();
									this.highlightNextUnit();
								}
								else
									this.hideWidget();
								break;
							default:
								//By default, hide the widget if it is tabbed out of
								this.hideWidget();
						}
					}
					break;
				case 13: // enter key
					e.preventDefault();
					this.updateFromElementVal();
					if (this.isOpen) {
						e.stopPropagation();
						this.hideWidget();
					}
					break;
				case 27: // escape
					this.updateFromElementVal();
					this.hideWidget();
					break;
				case 37: // left arrow
					e.preventDefault();
					if (this.isOpen)
						e.stopPropagation();
					if (!this.$element.val())
						break;
					if (this.highlightedUnit) {
						this.highlightPrevUnit();
						this.updateFromElementVal();
					} else {
						// highlight the unit so the parts can be modified
						this.highlightUnit();
					}
					break;
				case 38: // up arrow
					e.preventDefault();
					if (this.isOpen) {
						e.stopPropagation();
						if (e.altKey)
							return this.hideWidget();
					}
					else
						break;
					switch (this.highlightedUnit) {
						case 'hour':
							this.incrementHour();
							this.highlightHour();
							break;
						case 'minute':
							this.incrementMinute();
							this.highlightMinute();
							break;
						case 'second':
							this.incrementSecond();
							this.highlightSecond();
							break;
						case 'meridian':
							this.toggleMeridian();
							this.highlightMeridian();
							break;
					}
					break;
				case 39: // right arrow
					e.preventDefault();
					if (this.isOpen)
						e.stopPropagation();
					if (!this.$element.val())
						break;
					if (this.highlightedUnit) {
						this.updateFromElementVal();
						this.highlightNextUnit();
					} else {
						// highlight the unit so the parts can be modified
						this.highlightUnit();
					}
					break;
				case 40: // down arrow
					e.preventDefault();
					if (!this.isOpen && e.altKey) {
						this.showWidget();
						e.stopPropagation();
						break;
					}
					if (this.isOpen)
						e.stopPropagation();
					else
						break;
					switch (this.highlightedUnit) {
						case 'hour':
							this.decrementHour();
							this.highlightHour();
							break;
						case 'minute':
							this.decrementMinute();
							this.highlightMinute();
							break;
						case 'second':
							this.decrementSecond();
							this.highlightSecond();
							break;
						case 'meridian':
							this.toggleMeridian();
							this.highlightMeridian();
							break;
					}
					break;
			}
		},

		formatTime: function (hour, minute, second, meridian) {
			hour = this.twoDigitHourFormat & hour < 10 ? '0' + hour: hour;
			minute = minute < 10 ? '0' + minute : minute;
			second = second < 10 ? '0' + second : second;

			return hour + this.timeSeparator + minute + (this.showSeconds ? this.timeSeparator + second : '') + (this.showMeridian ? ' ' + meridian : '');
		},

		getCursorPosition: function () {
			var input = this.$element.get(0);

			if ('selectionStart' in input) {// Standard-compliant browsers

				return input.selectionStart;
			} else if (document.selection) {// IE fix
				input.focus();
				var sel = document.selection.createRange(),
				selLen = document.selection.createRange().text.length;

				sel.moveStart('character', -input.value.length);

				return sel.text.length - selLen;
			}
		},

		getTemplate: function () {
			var template,
				hourTemplate,
				minuteTemplate,
				secondTemplate,
				meridianTemplate,
				templateContent;

			if (this.showInputs) {
				hourTemplate = '<input type="text" name="hour" class="cognito-timepicker-hour" maxlength="2"/>';
				minuteTemplate = '<input type="text" name="minute" class="cognito-timepicker-minute" maxlength="2"/>';
				secondTemplate = '<input type="text" name="second" class="cognito-timepicker-second" maxlength="2"/>';
				meridianTemplate = '<input type="text" name="meridian" class="cognito-timepicker-meridian" maxlength="2"/>';
			} else {
				hourTemplate = '<span class="cognito-timepicker-hour"></span>';
				minuteTemplate = '<span class="cognito-timepicker-minute"></span>';
				secondTemplate = '<span class="cognito-timepicker-second"></span>';
				meridianTemplate = '<span class="cognito-timepicker-meridian"></span>';
			}

			templateContent = '<table>' +
				'<tr>' +
				'<td><a href="#" data-action="incrementHour"><i class="icon-chevron-up"></i></a></td>' +
				'<td class="separator">&nbsp;</td>' +
				'<td><a href="#" data-action="incrementMinute"><i class="icon-chevron-up"></i></a></td>' +
				(this.showSeconds ?
					'<td class="separator">&nbsp;</td>' +
					'<td><a href="#" data-action="incrementSecond"><i class="icon-chevron-up"></i></a></td>'
					: '') +
				(this.showMeridian ?
					'<td class="separator">&nbsp;</td>' +
					'<td class="meridian-column"><a href="#" data-action="toggleMeridian"><i class="icon-chevron-up"></i></a></td>'
					: '') +
				'</tr>' +
				'<tr>' +
				'<td>' + hourTemplate + '</td> ' +
				'<td class="separator">' + this.timeSeparator + '</td>' +
				'<td>' + minuteTemplate + '</td> ' +
				(this.showSeconds ?
					'<td class="separator">' + this.timeSeparator + '</td>' +
					'<td>' + secondTemplate + '</td>'
					: '') +
				(this.showMeridian ?
					'<td class="separator">&nbsp;</td>' +
					'<td>' + meridianTemplate + '</td>'
					: '') +
				'</tr>' +
				'<tr>' +
				'<td><a href="#" data-action="decrementHour"><i class="icon-chevron-down"></i></a></td>' +
				'<td class="separator"></td>' +
				'<td><a href="#" data-action="decrementMinute"><i class="icon-chevron-down"></i></a></td>' +
				(this.showSeconds ?
					'<td class="separator">&nbsp;</td>' +
					'<td><a href="#" data-action="decrementSecond"><i class="icon-chevron-down"></i></a></td>'
					: '') +
				(this.showMeridian ?
					'<td class="separator">&nbsp;</td>' +
					'<td><a href="#" data-action="toggleMeridian"><i class="icon-chevron-down"></i></a></td>'
					: '') +
				'</tr>' +
				'</table>';

			switch (this.template) {
				case 'modal':
					template = '<div class="cognito-timepicker-widget modal hide fade in" data-backdrop="' + (this.modalBackdrop ? 'true' : 'false') + '">' +
						'<div class="modal-header">' +
						'<a href="#" class="close" data-dismiss="modal">×</a>' +
						'<h3>Pick a Time</h3>' +
						'</div>' +
						'<div class="modal-content">' +
						templateContent +
						'</div>' +
						'<div class="modal-footer">' +
						'<a href="#" class="btn btn-primary" data-dismiss="modal">OK</a>' +
						'</div>' +
						'</div>';
					break;
				case 'dropdown':
					template = '<div class="cognito-timepicker-widget cognito-dropdown-menu">' + templateContent + '</div>';
					break;
			}

			return template;
		},

		getTime: function () {
			return this.formatTime(this.hour, this.minute, this.second, this.meridian);
		},

		hideWidget: function () {
			if (this.isOpen === false) {
				return;
			}

			if (this.showInputs) {
				this.updateFromElementVal();
			}

			this.$element.trigger({
				'type': 'hide.timepicker',
				'time': {
					'value': this.getTime(),
					'hours': this.hour,
					'minutes': this.minute,
					'seconds': this.second,
					'meridian': this.meridian
				}
			});

			if (this.template === 'modal' && this.$widget.modal) {
				this.$widget.modal('hide');
			} else {
				this.$widget.removeClass('open');
			}

			$(document).off('mousedown.timepicker');
			$(document).off('resize.timepicker');

			this.isOpen = false;
		},

		showOrHighlight: function () {
			if (!this.isOpen) {
				this.showWidget();
			}
			this.highlightUnit();
		},

		highlightUnit: function () {
			this.position = this.getCursorPosition();
			if (this.position >= 0 && this.position <= 2) {
				this.highlightHour();
			} else if (this.position >= 3 && this.position <= 5) {
				this.highlightMinute();
			} else if (this.position >= 6 && this.position <= 8) {
				if (this.showSeconds) {
					this.highlightSecond();
				} else {
					this.highlightMeridian();
				}
			} else if (this.position >= 9 && this.position <= 11) {
				this.highlightMeridian();
			}
		},

		highlightNextUnit: function () {
			switch (this.highlightedUnit) {
				case 'hour':
					this.highlightMinute();
					break;
				case 'minute':
					if (this.showSeconds) {
						this.highlightSecond();
					} else if (this.showMeridian) {
						this.highlightMeridian();
					}
					break;
				case 'second':
					if (this.showMeridian) {
						this.highlightMeridian();
					} 
					break;
				//case 'meridian':
				//	this.highlightHour();
				//	break;
			}
		},

		highlightPrevUnit: function () {
			switch (this.highlightedUnit) {
				//case 'hour':
				//	this.highlightMeridian();
				//	break;
				case 'minute':
					this.highlightHour();
					break;
				case 'second':
					this.highlightMinute();
					break;
				case 'meridian':
					if (this.showSeconds) {
						this.highlightSecond();
					} else {
						this.highlightMinute();
					}
					break;
			}
		},

		//Universal function for executing the highlighting on select units
		highlightElement: function (startIndex, endIndex) {

			var $element = this.$element.get(0);

			var mod = !this.twoDigitHourFormat && this.hour < 10 ? -1 : 0;
			startIndex = startIndex + mod < 0 ? 0 : startIndex + mod;
			endIndex = endIndex + mod > $($element).val().length ? $($element).val().length : endIndex + mod;
			
			if ($element.setSelectionRange) {
				setTimeout(function () {
					$element.setSelectionRange(startIndex, endIndex);
				}, 0);
			}
		},

		highlightHour: function () {
			this.highlightedUnit = "hour";
			this.highlightElement(0, 2);
		},

		highlightMinute: function () {			
			this.highlightedUnit = 'minute';
			this.highlightElement(3, 5);
		},

		highlightSecond: function () {
			this.highlightedUnit = 'second';
			this.highlightElement(6, 8);
		},

		highlightMeridian: function () {
			this.highlightedUnit = 'meridian';

			if (this.showSeconds) {
				this.highlightElement(9, 11);
			} else {
				this.highlightElement(6, 8);
			}
		},

		incrementHour: function () {
			if (this.showMeridian) {
				if (this.hour === 11) {
					this.hour++;
					return this.toggleMeridian();
				} else if (this.hour === 12) {
					this.hour = 0;
				}
			}
			if (this.hour === 23) {
				this.hour = 0;
			} else {
				this.hour++;
			}
			this.update();
		},

		incrementMinute: function (step) {
			var newVal;

			if (step) {
				newVal = this.minute + step;
			} else {
				newVal = this.minute + this.minuteStep - (this.minute % this.minuteStep);
			}

			if (newVal > 59) {
				this.incrementHour();
				this.minute = newVal - 60;
			} else {
				this.minute = newVal;
			}
			this.update();
		},

		incrementSecond: function () {
			var newVal = this.second + this.secondStep - (this.second % this.secondStep);

			if (newVal > 59) {
				this.incrementMinute(true);
				this.second = newVal - 60;
			} else {
				this.second = newVal;
			}
			this.update();
		},

		remove: function () {
			$('document').off('.timepicker');
			if (this.$widget) {
				this.$widget.remove();
			}
			delete this.$element.data().timepicker;
		},

		setDefaultTime: function (defaultTime) {
			if (!this.$element.val()) {
				if (defaultTime === 'current') {
					var dTime = new Date(),
					hours = dTime.getHours(),
					minutes = Math.floor(dTime.getMinutes() / this.minuteStep) * this.minuteStep,
					seconds = Math.floor(dTime.getSeconds() / this.secondStep) * this.secondStep,
					meridian = this.AMDesignator;

					if (this.showMeridian) {
						if (hours === 0) {
							hours = 12;
						} else if (hours >= 12) {
							if (hours > 12) {
								hours = hours - 12;
							}
							meridian = this.PMDesignator;
						} else {
							meridian = this.AMDesignator;
						}
					}

					this.hour = hours;
					this.minute = minutes;
					this.second = seconds;
					this.meridian = meridian;

				} else if (defaultTime === false) {
					this.hour = 0;
					this.minute = 0;
					this.second = 0;
					this.meridian = this.AMDesignator;
				} else {
					this.setTime(defaultTime);
				}
			} else {
				this.updateFromElementVal();
			}
		},

		setTime: function (time) {
			var arr,
			timeArray;

            if (this.showMeridian) {                
                arr = time.split(' ');                
                timeArray = arr[0].split(this.timeSeparator);
				this.meridian = time.substr(time.indexOf(' ') + 1);
			} else {
				timeArray = time.split(this.timeSeparator);
			}

			this.hour = parseInt(timeArray[0], 10);
			this.minute = parseInt(timeArray[1], 10);
			this.second = parseInt(timeArray[2], 10);

			if (isNaN(this.hour)) {
				this.hour = 0;
			}
			if (isNaN(this.minute)) {
				this.minute = 0;
			}

			if (this.showMeridian) {
				if (this.hour > 12) {
					this.hour = 12;
				} else if (this.hour < 1) {
					this.hour = 12;
				}

				if (this.meridian.toUpperCase() !== this.AMDesignator.toUpperCase() && this.meridian.toUpperCase() !== this.PMDesignator.toUpperCase()) {
					this.meridian = this.AMDesignator;
				}
			} else {
				if (this.hour >= 24) {
					this.hour = 23;
				} else if (this.hour < 0) {
					this.hour = 0;
				}
			}

			if (this.minute < 0) {
				this.minute = 0;
			} else if (this.minute >= 60) {
				this.minute = 59;
			}

			if (this.showSeconds) {
				if (isNaN(this.second)) {
					this.second = 0;
				} else if (this.second < 0) {
					this.second = 0;
				} else if (this.second >= 60) {
					this.second = 59;
				}
			}

			this.update();
		},

		place: function () {
			var scrollTop = $(window).scrollTop();
			var widgetWidth = this.$widget.width();
			var widgetHeight = this.$widget.height();
			var windowWidth = $(window).width();
			var windowHeight = $(window).height();

			var offset = this.$element.offset();
			var height = this.$element.outerHeight(false);
			var width = this.$element.outerWidth(false);
			var top = offset.top;
			var left = offset.left;

			this.$widget.removeClass('cognito-timepicker-orient-top cognito-timepicker-orient-bottom');

			var yorient;
			var topOverflow = -scrollTop + offset.top - widgetHeight;
			var bottomOverflow = scrollTop + windowHeight - (offset.top + height + widgetHeight);
			if (Math.max(topOverflow, bottomOverflow) === bottomOverflow)
				yorient = 'top';
			else
				yorient = 'bottom';

			this.$widget.addClass('cognito-timepicker-orient-' + yorient);
			if (yorient === 'top')
				top += height + 6;
			else
				top -= widgetHeight + parseInt(this.$widget.css('padding-top')) + 8;

			this.$widget.css({
				top: top,
				left: left
			});
		},

		//Toggles the widget open and close
		toggleWidget: function () {
			if (this.isOpen === true) {
				this.hideWidget();
			}
			else {
				this.showWidget();
			}
		},
		
		showWidget: function () {
			if (this.isOpen) {
				return;
			}

			if (this.$element.is(':disabled')) {
				return;
			}

			//If the time has not been set when the widget is opened, set it to it's default time
			if (this.getTime() == '0' + this.timeSeparator + '00 ' + this.AMDesignator)
				this.setDefaultTime(this.defaultTime);
			this.updateWidget();

			this.place();

			var self = this;
			$(document).on('mousedown.timepicker', function (e) {
				
				//If there is an open time picker widget and the target is not the time picker, it's icon, or it's field, then close the widget
				if (
					$(e.target).closest('.cognito-timepicker-widget').length === 0 
					&& (
						//the user is not clicking the editor or icon that belongs to this field
                        !(self.$element.is(e.target) ||
                            e.target.className.indexOf("c-editor-time") > -1 ||
                            e.target.className.indexOf("icon-time") > -1 ||
                            e.target.className.indexOf("time-icon") > -1)
						|| $(e.target).parents(".c-date-time")[0] !== $(self.$element).parents(".c-date-time")[0]
					)
				) {
					self.hideWidget();
				}
			});

			//Replace on document resize
			$(document).on('resize.timepicker', function (e) {
				self.place();
			});

			this.$element.trigger({
				'type': 'show.timepicker',
				'time': {
					'value': this.getTime(),
					'hours': this.hour,
					'minutes': this.minute,
					'seconds': this.second,
					'meridian': this.meridian
				}
			});

			if (this.disableFocus) {
				this.$element.blur();
			}

			this.updateFromElementVal();

			if (this.template === 'modal' && this.$widget.modal) {
				this.$widget.modal('show').on('hidden', $.proxy(this.hideWidget, this));
			} else {
				if (this.isOpen === false) {
					this.$widget.addClass('open');
				}
			}

			this.isOpen = true;
		},

		toggleMeridian: function () {
			this.meridian = this.meridian === this.AMDesignator ? this.PMDesignator : this.AMDesignator;
			this.update();
		},

		update: function () {
			this.updateElement();

			this.$element.trigger({
				'type': 'changeTime.timepicker',
				'time': {
					'value': this.getTime(),
					'hours': this.hour,
					'minutes': this.minute,
					'seconds': this.second,
					'meridian': this.meridian
				}
			});

			this.updateWidget();
		},

		updateElement: function () {
			this.$element.val(this.getTime()).change();
		},

		updateFromElementVal: function () {
			var val = this.$element.val();

			if (val) {
				this.setTime(val);
			}
		},

		updateWidget: function () {
			if (this.$widget === false) {
				return;
			}

			var hour = this.hour < 10 ? '0' + this.hour : this.hour,
				minute = this.minute < 10 ? '0' + this.minute : this.minute,
				second = this.second < 10 ? '0' + this.second : this.second;

			if (this.showInputs) {
				this.$widget.find('input.cognito-timepicker-hour').val(hour);
				this.$widget.find('input.cognito-timepicker-minute').val(minute);

				if (this.showSeconds) {
					this.$widget.find('input.cognito-timepicker-second').val(second);
				}
				if (this.showMeridian) {
					this.$widget.find('input.cognito-timepicker-meridian').val(this.meridian);
				}
			} else {
				this.$widget.find('span.cognito-timepicker-hour').text(hour);
				this.$widget.find('span.cognito-timepicker-minute').text(minute);

				if (this.showSeconds) {
					this.$widget.find('span.cognito-timepicker-second').text(second);
				}
				if (this.showMeridian) {
					this.$widget.find('span.cognito-timepicker-meridian').text(this.meridian);
				}
			}
		},

		updateFromWidgetInputs: function () {
			if (this.$widget === false || this.$element.val() === "") {
				return;
			}

			var time = $('input.cognito-timepicker-hour', this.$widget).val() + this.timeSeparator +
				$('input.cognito-timepicker-minute', this.$widget).val() +
				(this.showSeconds ? this.timeSeparator + $('input.cognito-timepicker-second', this.$widget).val() : '') +
				(this.showMeridian ? ' ' + $('input.cognito-timepicker-meridian', this.$widget).val() : '');

			this.setTime(time);
		},

		widgetClick: function (e) {
			e.stopPropagation();
			e.preventDefault();

			var action = $(e.target).closest('a').data('action');
			if (action) {
				this[action]();
			}
		},

		widgetKeydown: function (e) {
			var $input = $(e.target).closest('input'),
				name = $input.attr('name');

			switch (e.keyCode) {
				case 9: //tab
					if (this.showMeridian) {
						if (name === 'meridian') {
							return this.hideWidget();
						}
					} else {
						if (this.showSeconds) {
							if (name === 'second') {
								return this.hideWidget();
							}
						} else {
							if (name === 'minute') {
								return this.hideWidget();
							}
						}
					}

					this.updateFromWidgetInputs();
					break;
				case 27: // escape
					this.hideWidget();
					break;
				case 38: // up arrow
					e.preventDefault();
					switch (name) {
						case 'hour':
							this.incrementHour();
							break;
						case 'minute':
							this.incrementMinute();
							break;
						case 'second':
							this.incrementSecond();
							break;
						case 'meridian':
							this.toggleMeridian();
							break;
					}
					break;
				case 40: // down arrow
					e.preventDefault();
					switch (name) {
						case 'hour':
							this.decrementHour();
							break;
						case 'minute':
							this.decrementMinute();
							break;
						case 'second':
							this.decrementSecond();
							break;
						case 'meridian':
							this.toggleMeridian();
							break;
					}
					break;
			}
		}
	};


	//TIMEPICKER PLUGIN DEFINITION
	$.fn.timepicker = function (option) {
		var args = Array.apply(null, arguments);
		args.shift();
		return this.each(function () {
			var $this = $(this),
			data = $this.data('timepicker'),
			options = typeof option === 'object' && option;

			if (!data) {
				$this.data('timepicker', (data = new Timepicker(this, $.extend({}, $.fn.timepicker.defaults, options, $(this).data()))));
			}

			if (typeof option === 'string') {
				data[option].apply(data, args);
			}
		});
	};

	$.fn.timepicker.defaults = {
		defaultTime: 'current',
		disableFocus: false,
		isOpen: false,
		minuteStep: 15,
		modalBackdrop: false,
		secondStep: 15,
		showSeconds: false,
		showInputs: true,
		showMeridian: true,
		template: 'dropdown',
		appendWidgetTo: '.cognito-timepicker',
		timeSeparator: ':',
		AMDesignator: "AM",
		PMDesignator: "PM",
		twoDigitHourFormat: false
	};

	$.fn.timepicker.Constructor = Timepicker;

})(jQuery, window, document);
})();
;(function() { if (Cognito.config.scripts.indexOf('cognito-typeahead') >= 0) return; else Cognito.config.scripts.push('cognito-typeahead');/**
* bootstrap-typeahead.js
* Copyright 2013 Twitter, Inc.
* http://www.apache.org/licenses/LICENSE-2.0.txt
*/
/* =============================================================
 * bootstrap-typeahead.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#typeahead
 * =============================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function ($) {

	"use strict"; // jshint ;_;


	/* TYPEAHEAD PUBLIC CLASS DEFINITION
	 * ================================= */

	var Typeahead = function (element, options) {
		this.$element = $(element)
		this.options = $.extend({}, $.fn.typeahead.defaults, options)
		this.matcher = this.options.matcher || this.matcher
		this.sorter = this.options.sorter || this.sorter
		this.highlighter = this.options.highlighter || this.highlighter
		this.updater = this.options.updater || this.updater
		this.source = this.options.source || $.map(this.$element[0].__msajaxbindings[0]._source.get_options(), function (val, i) { return val.get_displayValue(); }),
		this.$menu = $(this.options.menu)
		this.shown = false
		this.listen()
	}

	Typeahead.prototype = {

		constructor: Typeahead

	, select: function () {
		var val = this.$menu.find('.active').attr('data-value')
		this.$element
		  .val(this.updater(val))
		  .change()

		$simulateMutationEvent(this.$element.get(0), "change", false, true)

		return this.hide()
	}

	, updater: function (item) {
		return item
	}

	, show: function () {
		var pos = $.extend({}, this.$element.position(), {
			height: this.$element[0].offsetHeight
		})

		this.$menu
		  .insertAfter(this.$element)
		  .css({
			top: pos.top + pos.height
		  , left: pos.left
		  })
		  .show()

		var $pageContainer = this.$element.closest('.c-forms-pages')
		if ($pageContainer.length) {
			var currentHeight = this.$menu.get(0).offsetHeight
			var maxHeight = $pageContainer.get(0).offsetHeight - (pos.top + pos.height);
			if (currentHeight > maxHeight) {
				this.$menu.css({
					height: maxHeight
					, overflow: 'auto'
				})
			}
		}

		this.shown = true
		return this
	}

	, hide: function () {
		this.$menu.hide()
		this.shown = false
		return this
	}

	, lookup: function (event) {
		var items

		this.query = this.$element.val()

		if (!this.query || this.query.length < this.options.minLength) {
			return this.shown ? this.hide() : this
		}

		items = $.isFunction(this.source) ? this.source(this.query, $.proxy(this.process, this)) : this.source

		return items ? this.process(items) : this
	}

	, process: function (items) {
		var that = this

		items = $.grep(items, function (item) {
			return that.matcher(item)
		})

		items = this.sorter(items)

		if (!items.length) {
			return this.shown ? this.hide() : this
		}

		return this.render(items.slice(0, this.options.items)).show()
	}

	, matcher: function (item) {
		return ~item.toLowerCase().indexOf(this.query.toLowerCase())
	}

	, sorter: function (items) {
		var beginswith = []
		  , caseSensitive = []
		  , caseInsensitive = []
		  , item

		while (item = items.shift()) {
			if (!item.toLowerCase().indexOf(this.query.toLowerCase())) beginswith.push(item)
			else if (~item.indexOf(this.query)) caseSensitive.push(item)
			else caseInsensitive.push(item)
		}

		return beginswith.concat(caseSensitive, caseInsensitive)
	}

	, highlighter: function (item) {
		var query = this.query.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&')
		return item.replace(new RegExp('(' + query + ')', 'ig'), function ($1, match) {
			return '<strong>' + match + '</strong>'
		})
	}

	, render: function (items) {
		var that = this

		items = $(items).map(function (i, item) {
			i = $(that.options.item).attr('data-value', item)
			i.find('a').html(that.highlighter(item))
			return i[0]
		})
		items.first().addClass('active')
		this.$menu.html(items)
		return this
	}

	, next: function (event) {
		var active = this.$menu.find('.active').removeClass('active')
		  , next = active.next()

		if (!next.length) {
			next = $(this.$menu.find('li')[0])
		}

		next.addClass('active')
		
		var index = parseInt(next.attr('data-index'));
		var liPos = (index + 1) * 26;
		if (index == 0)
			this.$menu.scrollTop(0);
		else if (liPos > this.$menu.height()+this.$menu.scrollTop())
			this.$menu.scrollTop(liPos - this.$menu.height());
	}

	, prev: function (event) {
		var active = this.$menu.find('.active').removeClass('active')
		  , prev = active.prev()
		var isLast = false;

		if (!prev.length) {
			prev = this.$menu.find('li').last()
			isLast = true;
		}

		prev.addClass('active')

		var index = parseInt(prev.attr('data-index'));
		var liPos = index * 26;
		if (isLast)
			this.$menu.scrollTop(liPos);
		else if (liPos < this.$menu.scrollTop())
			this.$menu.scrollTop(liPos);
	}

	, listen: function () {
		this.$element
		  .on('focus', $.proxy(this.focus, this))
		  .on('blur', $.proxy(this.blur, this))
		  .on('keyup', $.proxy(this.keyup, this))

		if (this.eventSupported('keydown')) {
			this.$element.on('keydown', $.proxy(this.keydown, this))
		}

		this.$menu
		  .on('click', $.proxy(this.click, this))
		  .on('mouseenter', 'li', $.proxy(this.mouseenter, this))
		  .on('mouseleave', 'li', $.proxy(this.mouseleave, this))
		  .on('mouseenter', $.proxy(this.mouseentermenu, this))
		  .on('mouseleave', $.proxy(this.mouseleavemenu, this))
		  .on('mouseup', $.proxy(this.mouseup, this))
	}

	, eventSupported: function (eventName) {
		var isSupported = eventName in this.$element
		if (!isSupported) {
			this.$element.setAttribute(eventName, 'return;')
			isSupported = typeof this.$element[eventName] === 'function'
		}
		return isSupported
	}

	, move: function (e) {
		if (!this.shown) return

		switch (e.keyCode) {
			case 9: // tab
			case 13: // enter
			case 27: // escape
				e.preventDefault()
				break

			case 38: // up arrow
				e.preventDefault()
				this.prev()
				break

			case 40: // down arrow
				e.preventDefault()
				this.next()
				break
		}

		e.stopPropagation()
	}

	, keydown: function (e) {
		this.suppressKeyPressRepeat = ~$.inArray(e.keyCode, [40, 38, 9, 13, 27])
		this.move(e)
	}

	, keyup: function (e) {
		switch (e.keyCode) {
			case 40: // down arrow
			case 38: // up arrow
			case 16: // shift
			case 17: // ctrl
			case 18: // alt
				break

			case 9: // tab
			case 13: // enter
				if (!this.shown) return
				this.select()
				break

			case 27: // escape
				if (!this.shown) return
				this.hide()
				break

			default:
				this.lookup()
		}

		e.stopPropagation()
		e.preventDefault()
	}

	, focus: function (e) {
		this.focused = true
	}

	, blur: function (e) {
		this.focused = false
		if (!this.mousedovermenu && this.shown) this.hide()
	}

	, click: function (e) {
		e.stopPropagation()
		e.preventDefault()
		this.select()
		this.$element.focus()
	}

	, mouseenter: function (e) {
		this.mousedover = true
		this.$menu.find('.active').removeClass('active')
		$(e.currentTarget).addClass('active')
	}

	, mouseleave: function (e) {
		this.mousedover = false
	}

	, mouseentermenu: function (e) {
		this.mousedovermenu = true
	}

	, mouseleavemenu: function (e) {
		this.mousedovermenu = false
	}

	, mouseup: function (e) {
		var selectedElement = this.$menu.find('.active')
		if (this.mousedovermenu && !this.mousedover) {
			this.focusItem = selectedElement
			this.$element.focus()
		}
	}

	}


	/* TYPEAHEAD PLUGIN DEFINITION
	 * =========================== */

	var old = $.fn.typeahead

	$.fn.typeahead = function (option) {
		return this.each(function () {
			var $this = $(this)
			  , data = $this.data('typeahead')
			  , options = typeof option == 'object' && option
			if (!data) $this.data('typeahead', (data = new Typeahead(this, options)))
			if (typeof option == 'string') data[option]()
		})
	}

	$.fn.typeahead.defaults = {
		source: []
	, items: 8
	, menu: '<ul class="typeahead dropdown-menu"></ul>'
	, item: '<li><a href="#"></a></li>'
	, minLength: 1
	}

	$.fn.typeahead.Constructor = Typeahead


	/* TYPEAHEAD NO CONFLICT
	 * =================== */

	$.fn.typeahead.noConflict = function () {
		$.fn.typeahead = old
		return this
	}


	/* TYPEAHEAD DATA-API
	 * ================== */

	$(document).on('focus.typeahead.data-api', '[data-provide="typeahead"]', function (e) {
		var $this = $(this)
		if ($this.data('typeahead')) return
		$this.typeahead($this.data())
	})

}(jQuery);

/* =============================================================
 * bootstrap-better-typeahead.js v1.0.0 by Philipp Nolte
 * https://github.com/ptnplanet/Bootstrap-Better-Typeahead
 * =============================================================
 * This plugin makes use of twitter bootstrap typeahead
 * http://twitter.github.com/bootstrap/javascript.html#typeahead
 *
 * Bootstrap is licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 * ============================================================ */

!function($) {

	"use strict";

	/**
	 * The better typeahead plugin will extend the bootstrap typeahead plugin and provide the ability to set the
	 * minLength option to zero. The tab keyup event handler had to be moved to the keydown event handler, so that
	 * the full list of available items is shown on tab-focus and the original behaviour is preserved as best as
	 * possible.
	 *
	 * @type {object}
	 */
	var BetterTypeahead = {

		lookup: function(event) {
			var items;

			// Now supports empty queries (eg. with a length of 0).
			this.query = this.$element.val() || '';

			if (this.query.length < this.options.minLength) {
				return this.shown ? this.hide() : this;
			}

			items = $.isFunction(this.source) ? this.source(this.query, $.proxy(this.process, this)) : this.source;

			return items ? this.process(items) : this;
		}

		, process: function (items) {
			var that = this;

			items = $.grep(items, function (item) {
				return that.matcher(item);
			});

			items = this.sorter(items);

			if (!items.length) {
				return this.shown ? this.hide() : this;
			}

			if (this.query.length) {
				items = items.slice(0, this.options.items);
			}
			if (this.focusItem) {
				this.focusItem = null;
				return;
			}
			return this.render(items).show();
		}

		, render: function (items) {
			var that = this

			items = $(items).map(function (i, item) {
				var li = $(that.options.item).attr('data-value', item);
				li.attr('data-index', i);
				li.find('a').html(that.highlighter(item));
				return li[0];
			});

			if (this.query.length > 0) {
				if (this.focusItem)
					return;
				else
					items.first().addClass('active');
			}

			this.$menu.html(items);
			return this;
		}

		, move: function (e) {
			if (!this.shown) return;

			switch (e.keyCode) {
				case 9: // tab
				case 13: // enter
					if (this.options.useTabToSelect === true)
						e.preventDefault();
					else if (this.shown) {
                        this.select()
						this.hide();
					}
					break;
				case 27: // escape
					e.preventDefault();
					break;

				case 38: // up arrow
					e.preventDefault();
					this.prev();
					e.stopPropagation();
					break;

				case 40: // down arrow
					e.preventDefault();
					this.next();
					e.stopPropagation();
					break;
			}
		}

		, keydown: function (e) {
			this.suppressKeyPressRepeat = ~$.inArray(e.keyCode, [40,38,9,13,27]);
			this.move(e);
		}

		, keyup: function (e) {
			switch(e.keyCode) {
			    case 37: // left
			    case 39: // right
			        return;
				case 40: // down arrow
				case 38: // up arrow
				case 16: // shift
				case 17: // ctrl
				case 18: // alt
					break;

				case 13: // enter
				case 9: // tab
					if (!this.shown) return;
					this.select();
					this.show();
					break;

				case 27: // escape;
					if (!this.shown) return;
					this.hide();
					break;

				default:
					this.lookup();
			}

			//if (!this.options.useTabToSelect)
            e.stopPropagation();
			e.preventDefault();
		}

		, focus: function(e) {
			this.focused = true;

			if (!this.mousedover) {
				this.lookup(e);
			}
		}
	};

	$.extend($.fn.typeahead.Constructor.prototype, BetterTypeahead);

}(jQuery);
})();
;(function() { if (Cognito.config.scripts.indexOf('cognito-toggle') >= 0) return; else Cognito.config.scripts.push('cognito-toggle');/*! ============================================================
 * bootstrapSwitch v1.8 by Larentis Mattia @SpiritualGuru
 * http://www.larentis.eu/
 *
 * Enhanced for radiobuttons by Stein, Peter @BdMdesigN
 * http://www.bdmdesign.org/
 *
 * Project site:
 * http://www.larentis.eu/switch/
 * ============================================================
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 * ============================================================ */

!function ($) {
	"use strict";

	$.fn['bootstrapSwitch'] = function (method) {
		var methods = {
			init: function () {
				return this.each(function () {
					var $element = $(this).parent()
					  , $input = $(this)
					  , $div
					  , $switchLeft
					  , $switchRight
					  , $label
					  , $form = $element.closest('form')
					  , myClasses = ""
					  , classes = $element.attr('class')
					  , color
					  , moving
					  , onLabel = "ON"
					  , offLabel = "OFF"
					  , icon = false
					  , textLabel = false;

					/*
					$.each(['switch-mini', 'switch-small', 'switch-large'], function (i, el) {
						if (classes.indexOf(el) >= 0)
							myClasses = el;
					});
					*/

					$element.addClass('has-switch');

					if ($element.data('on') !== undefined)
						color = "switch-" + $element.data('on');

					if ($element.data('on-label') !== undefined)
						onLabel = $element.data('on-label');

					if ($element.data('off-label') !== undefined)
						offLabel = $element.data('off-label');

					if ($element.data('label-icon') !== undefined)
						icon = $element.data('label-icon');

					if ($element.data('text-label') !== undefined)
						textLabel = $element.data('text-label');

					$switchLeft = $('<span>')
					  .addClass("switch-left")
					  .addClass(myClasses)
					  .addClass(color)
					  .html('' + onLabel + '');

					color = '';
					if ($element.data('off') !== undefined)
						color = "switch-" + $element.data('off');

					$switchRight = $('<span>')
					  .addClass("switch-right")
					  .addClass(myClasses)
					  .addClass(color)
					  .html('' + offLabel + '');

					$label = $('<label>')
					  .html("&nbsp;")
					  .addClass(myClasses)
					  .attr('for', $input.attr('id'));

					if (icon) {
						$label.html('<i class="icon ' + icon + '"></i>');
					}

					if (textLabel) {
						$label.html('' + textLabel + '');
					}

					$div = $input.wrap($('<div>')).parent().data('animated', false);

					if ($element.data('animated') !== false)
						$div.addClass('switch-animate').data('animated', true);

					$div
					  .append($switchLeft)
					  .append($label)
					  .append($switchRight);

					$element.find('>div').addClass(
					  $input.is(':checked') ? 'switch-on' : 'switch-off'
					);

					if ($input.is(':disabled'))
						$(this).addClass('deactivate');

					var changeStatus = function ($this) {
						if ($element.parent('label').is('.label-change-switch')) {

						} else {
							$this.siblings('label').trigger('mousedown').trigger('mouseup').trigger('click');
						}
					};

					$element.on('keydown', function (e) {
						if (e.keyCode === 32) {
							e.stopImmediatePropagation();
							e.preventDefault();
							changeStatus($(e.target).find('span:first'));
						}
					});

					$switchLeft.on('click', function (e) {
						changeStatus($(this));
					});

					$switchRight.on('click', function (e) {
						changeStatus($(this));
					});

					$input.on('change', function (e, skipOnChange) {
						var $this = $(this)
						  , $element = $this.parent()
						  , thisState = $this.is(':checked')
						  , state = $element.is('.switch-off');

						e.preventDefault();

						$element.css('left', '');

						if (state === thisState) {

							if (thisState)
								$element.removeClass('switch-off').addClass('switch-on');
							else $element.removeClass('switch-on').addClass('switch-off');

							if ($element.data('animated') !== false)
								$element.addClass("switch-animate");

							if (typeof skipOnChange === 'boolean' && skipOnChange)
								return;

							$element.parent().trigger('switch-change', { 'el': $this, 'value': thisState })
						}
					});

					$element.find('label').on('mousedown touchstart', function (e) {
						var $this = $(this);
						moving = false;

						e.preventDefault();
						e.stopImmediatePropagation();

						$this.closest('div').removeClass('switch-animate');

						if ($this.closest('.has-switch').is('.deactivate')) {
							$this.unbind('click');
						} else if ($this.closest('.switch-on').parent().is('.radio-no-uncheck')) {
							$this.unbind('click');
						} else {
							$this.on('mousemove touchmove', function (e) {
								var $element = $(this).parents(".has-switch")
								  , relativeX = (e.pageX || e.originalEvent.targetTouches[0].pageX) - $element.offset().left
								  , percent = (relativeX / $element.width()) * 100
								  , left = 25
								  , right = 75;

								moving = true;

								if (percent < left)
									percent = left;
								else if (percent > right)
									percent = right;

								$element.find('>div').css('left', (percent - right) + "%")
							});

							$this.on('click touchend', function (e) {
								var $this = $(this)
								  , $myInputBox = $this.siblings('input');

								e.stopImmediatePropagation();
								e.preventDefault();

								$this.unbind('mouseleave');

								if (moving)
									$myInputBox.prop('checked', !(parseInt($this.parent().css('left')) < -25));
								else
									$myInputBox.prop("checked", !$myInputBox.is(":checked"));

								moving = false;
								$myInputBox.trigger('change');
							});

							$this.on('mouseleave', function (e) {
								var $this = $(this)
								  , $myInputBox = $this.siblings('input');

								e.preventDefault();
								e.stopImmediatePropagation();

								$this.unbind('mouseleave mousemove');
								$this.trigger('mouseup');

								$myInputBox.prop('checked', !(parseInt($this.parent().css('left')) < -25)).trigger('change');
							});

							$this.on('mouseup', function (e) {
								e.stopImmediatePropagation();
								e.preventDefault();

								$(this).trigger('mouseleave');
							});
						}
					});

					if ($form.data('bootstrapSwitch') !== 'injected') {
						$form.bind('reset', function () {
							setTimeout(function () {
								$form.find('.c-toggle').each(function () {
									$input.prop('checked', $input.is(':checked')).trigger('change');
								});
							}, 1);
						});
						$form.data('bootstrapSwitch', 'injected');
					}
				}
				);
			},
			toggleActivation: function () {
				var $element = $(this).parent();
				var $this = $(this);

				$element.toggleClass('deactivate');
				$this.prop('disabled', $element.is('.deactivate'));
			},
			isActive: function () {
				return !$(this).hasClass('deactivate');
			},
			setActive: function (active) {
				var $element = $(this).parent();
				var $this = $(this);

				if (active) {
					$element.removeClass('deactivate');
					$this.removeAttr('disabled');
				}
				else {
					$element.addClass('deactivate');
					$this.attr('disabled', 'disabled');
				}
			},
			toggleState: function (skipOnChange) {
				var $input = $(this).find(':checkbox');
				$input.prop('checked', !$input.is(':checked')).trigger('change', skipOnChange);
			},
			toggleRadioState: function (skipOnChange) {
				var $radioinput = $(this).find(':radio');
				$radioinput.not(':checked').prop('checked', !$radioinput.is(':checked')).trigger('change', skipOnChange);
			},
			toggleRadioStateAllowUncheck: function (uncheck, skipOnChange) {
				var $radioinput = $(this).find(':radio');
				if (uncheck) {
					$radioinput.not(':checked').trigger('change', skipOnChange);
				}
				else {
					$radioinput.not(':checked').prop('checked', !$radioinput.is(':checked')).trigger('change', skipOnChange);
				}
			},
			setState: function (value, skipOnChange) {
				$(this).prop('checked', value).trigger('change', skipOnChange);
			},
			setOnLabel: function (value) {
				var $switchLeft = $(this).find(".switch-left");
				$switchLeft.html(value);
			},
			setOffLabel: function (value) {
				var $switchRight = $(this).find(".switch-right");
				$switchRight.html(value);
			},
			setOnClass: function (value) {
				var $switchLeft = $(this).find(".switch-left");
				var color = '';
				if (value !== undefined) {
					if ($(this).attr('data-on') !== undefined) {
						color = "switch-" + $(this).attr('data-on')
					}
					$switchLeft.removeClass(color);
					color = "switch-" + value;
					$switchLeft.addClass(color);
				}
			},
			setOffClass: function (value) {
				var $switchRight = $(this).find(".switch-right");
				var color = '';
				if (value !== undefined) {
					if ($(this).attr('data-off') !== undefined) {
						color = "switch-" + $(this).attr('data-off')
					}
					$switchRight.removeClass(color);
					color = "switch-" + value;
					$switchRight.addClass(color);
				}
			},
			setAnimated: function (value) {
				var $element = $(this);
				if (value === undefined) value = false;
				$element.data('animated', value);
				$element.attr('data-animated', value);

				if ($element.data('animated') !== false) {
					$element.addClass("switch-animate");
				} else {
					$element.removeClass("switch-animate");
				}
			},
			setSizeClass: function (value) {
				var $element = $(this);
				var $switchLeft = $element.find(".switch-left");
				var $switchRight = $element.find(".switch-right");
				var $label = $element.find("label");
				$.each(['switch-mini', 'switch-small', 'switch-large'], function (i, el) {
					if (el !== value) {
						$switchLeft.removeClass(el);
						$switchRight.removeClass(el);
						$label.removeClass(el);
					} else {
						$switchLeft.addClass(el);
						$switchRight.addClass(el);
						$label.addClass(el);
					}
				});
			},
			status: function () {
				return $(this).find(inputSelector).is(':checked');
			},
			destroy: function () {
				var $element = $(this)
				  , $div = $element.find('div')
				  , $form = $element.closest('form')
				  , $inputbox;

				$div.find(':not(input)').remove();

				$inputbox = $div.children();
				$inputbox.unwrap().unwrap();

				$inputbox.unbind('change');

				if ($form) {
					$form.unbind('reset');
					$form.removeData('bootstrapSwitch');
				}

				return $inputbox;
			}
		};

		if (methods[method])
			return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
		else if (typeof method === 'object' || !method)
			return methods.init.apply(this, arguments);
		else
			$.error('Method ' + method + ' does not exist!');
	};
}(jQuery);
})();
;(function() { if (Cognito.config.scripts.indexOf('cognito-messaging') >= 0) return; else Cognito.config.scripts.push('cognito-messaging');;
window.Cognito = window.Cognito || {};
(function (window) {
	var _handlers = {};

	var Messaging = function () {
		var eventMethod = window.addEventListener ? "addEventListener" : "attachEvent";
		var event = window.addEventListener ? "message" : "onmessage";
		var eventer = window[eventMethod];

		eventer(event, this._handle, false);
	}

	// Get the value at the specified property path
	function evalPath(obj, path) {
		function index(obj, i) { return obj[i] }
		return path.split('.').reduce(index, obj);
	}

	Messaging.prototype = {
		_handle: function (event) {
			try {
				var payload = JSON.parse(event.data);
			}
			catch (e)
			{ }

			if (payload && payload.event) {
				var handlerList = _handlers[payload.event];

				if (handlerList) {
                    handlerList.forEach(function (handler) {
                        handler.call(event, payload.data);
                    });
				}
			}
		},

		addHandler: function (name, handler) {
            _handlers[name] = _handlers[name] || [];
            _handlers[name].push(handler);
		},

		trigger: function (/* [event,] options */) {
			var event;
			var options;

			if (arguments.length === 2) {
				event = arguments[0];
				options = arguments[1];
			} else if (arguments.length === 1) {
				if (typeof (arguments[0]) === "string") {
					event = arguments[0];
				} else {
					options = arguments[0];
					event = options.event;
				}
			}

			var payload = {};
			payload["event"] = event;

			if (options && options.data) {
					payload["data"] = options.data;
			}

			var target = (options && options.target) || window.parent;
			var origin = (options && options.origin) || "*";

			target.postMessage(JSON.stringify(payload), origin);
		},

		// Creates a proxy for a set of functions that can be safely called across frame boundaries
		proxy: function (target, scope) {

			// Get the function set for the specified target and scope
			var fnSet = evalPath(target, scope);
			var proxy = {};

			// Define a closure to create a proxy wrapper function
			function createProxy(fn) {
				return function () {
					var args = [];
					for (var i = 0; i < arguments.length; i++) {
						arg = arguments[i];

						// Serialize Entity
						if (arg instanceof ExoWeb.Model.Entity) {
							var type = arg.meta.type.get_fullName();
							arg = Cognito.serialize(arg);
							arg.$type = arg.$type || type;
						}

						// Serialize Entity Array
						else if (arg instanceof Array && arg.length > 0 && arg[0] instanceof ExoWeb.Model.Entity) {
							for (var j = 0; j < arg.length; j++) {
								var type = arg[j].meta.type.get_fullName();
								arg[j] = Cognito.serialize(arg[j]);
								arg[j].$type = arg[j].$type || type;
							}
						}

						// Cleanse Arrays
						else if (arg instanceof Array) {
							if (arg.length > 0 && arg[0] instanceof Object) {
								for (var j = 0; j < arg.length; j++) {
									var obj = arg[j];
									var clean = {};
									for (var prop in obj) {
										var val = obj[prop];
										if (val instanceof ExoWeb.Model.Entity || (val instanceof Array && val.length > 0 && val[0] instanceof ExoWeb.Model.Entity))
											continue;
										clean[prop] = val;
									}
									arg[j] = clean;
								}
							}
						}

						// Cleanse Objects
						else if (arg instanceof Object) {
							var clean = {};
							for (var prop in arg) {
								var val = arg[prop];
								if (val instanceof ExoWeb.Model.Entity || (val instanceof Array && val.length > 0 && val[0] instanceof ExoWeb.Model.Entity))
									continue;
								clean[prop] = val;
							}
							arg = clean;
						}						

						args.push(arg);
					}
					Cognito.Messaging.trigger("proxy", { target: target, data: { scope: scope, fn: fn, args: args } });
				};
			}

			// Create proxy functions for each function in the set
			for (var fn in fnSet) {
				proxy[fn] = createProxy(fn);
			}

			return proxy;
		}
	};

	window.Cognito.Messaging = new Messaging();

	// Add a default event handler to generically support controller proxies
	Cognito.Messaging.addHandler("proxy", function (data) {
		for (var i = 0; i < data.args.length; i++) {
			arg = data.args[i];

			// Deserialize Entity
			if (arg && arg.$type) {
				var entity = null;
				if (arg.Id) {
					var type = context.model.meta.type(arg.$type).get_jstype();
					entity = type.meta.get(arg.Id.toString());
				}	
				data.args[i] = Cognito.deserialize(null, arg, entity);
			}

			// Deserialize Entity Array
			if (arg && arg instanceof Array && arg.length > 0 && arg[0].$type) {
				var type = context.model.meta.type(arg[0].$type).get_jstype();
				for (var j = 0; j < arg.length; j++) {
					var entity = null;
					if (arg[j].Id)
						entity = type.meta.get(arg.Id.toString());
					arg[j] = Cognito.deserialize(null, arg[j], entity);
				}
			}
		}
		evalPath(window, data.scope)[data.fn].apply(window, data.args);
	});
})(window);
})();
;(function() { if (Cognito.config.scripts.indexOf('cognito-scrollintoview') >= 0) return; else Cognito.config.scripts.push('cognito-scrollintoview');(function ($) {
	$.fn.scrollIntoView = function () {
		if (Cognito.config.embedMode == "iframe") {
			this.get(0).scrollIntoView();
			return this;
		}

		// Find the scrollable parent container if one exists
		var $parent = this.parents().filter(function () {
			return this.clientHeight < (this.scrollHeight - 1) // ignoring 1px difference seen in IE
				&& ($(this).css("overflow-y") != "visible" || (this.tagName.toLowerCase() == "html" || this.tagName.toLowerCase() == "body"));
		});

		if ($parent.length > 0) {
			var parentTagName = $parent.get(0).tagName.toLowerCase();

			// Calculate the distance relative to the top of the offsetParent. The offsetParent if the closest positioned containing element. 
			var offset = this.get(0).offsetTop;

			// If the scrollable parent container is the html/body element then calculate the distance between the elements based on their distance relative to the document.
			if (parentTagName == "body" || parentTagName == "html") {
				// Need to inlcude both the "html" and the "body" element to ensure cross browser compatibility
				// In IE, you need to set the scrollTop on the "html" element; while in Chrome, you need to set the scrollTop on the "body" element
				$parent = ExoJQuery("html, body");
				offset = this.offset().top - $parent.offset().top;
			}

			$parent.animate({ scrollTop: offset }, 300);
		}
		else
			this.get(0).scrollIntoView();

		return this;
	};

})(ExoJQuery || jQuery);
})();
;(function() { if (Cognito.config.scripts.indexOf('jquery.maskedinput') >= 0) return; else Cognito.config.scripts.push('jquery.maskedinput');/*
    jQuery Masked Input Plugin
    Copyright (c) 2007 - 2015 Josh Bush (digitalbush.com)
    Licensed under the MIT license (http://digitalbush.com/projects/masked-input-plugin/#license)
    Version: 1.4.1.2018 (v1.4.1, modified for Cognito's purposes...)
*/
(function ($) {
	var ua = navigator.userAgent,
		iPhone = /iphone/i.test(ua),
		chrome = /chrome/i.test(ua),
		android = /android/i.test(ua),
		caretTimeoutId;

	$.mask = {
		//Predefined character definitions
		definitions: {
			'#': "[0-9]",
			'@': "[A-Za-z]"
		},
		autoclear: true,
		autoinit: true,
		dataName: "rawMaskFn",
		placeholder: '_'
	};

	$.fn.extend({
		//Helper Function for Caret positioning
		caret: function(begin, end) {
			var range;

			if (this.length === 0 || this.is(":hidden") || this.get(0) !== document.activeElement) {
				return;
			}

			if (typeof begin == 'number') {
				end = (typeof end === 'number') ? end : begin;
				return this.each(function() {
					if (this.setSelectionRange) {
						this.setSelectionRange(begin, end);
					} else if (this.createTextRange) {
						range = this.createTextRange();
						range.collapse(true);
						range.moveEnd('character', end);
						range.moveStart('character', begin);
						range.select();
					}
				});
			} else {
				if (this[0].setSelectionRange) {
					begin = this[0].selectionStart;
					end = this[0].selectionEnd;
				} else if (document.selection && document.selection.createRange) {
					range = document.selection.createRange();
					begin = 0 - range.duplicate().moveStart('character', -100000);
					end = begin + range.text.length;
				}
				return { begin: begin, end: end };
			}
		},
		unmask: function() {
			return this.trigger("unmask");
		},
		mask: function(mask, settings) {
			var input,
				defs,
				tests,
				hasPartialPosition,
				partialPosition,
				firstNonMaskPos,
				lastRequiredNonMaskPos,
				len,
				oldVal;

			if (!mask && this.length > 0) {
				input = $(this[0]);
				var fn = input.data($.mask.dataName)
				return fn?fn():undefined;
			}

			settings = $.extend({
				autoclear: $.mask.autoclear,
				autoinit: $.mask.autoinit,
				placeholder: $.mask.placeholder, // Load default placeholder
				completed: null
			}, settings);


			defs = $.mask.definitions;
			tests = [];
			hasPartialPosition = false;
			partialPosition = null;
			len = mask.length;
			firstNonMaskPos = null;

			mask = String(mask);

			var maskPart;
			var maskPartFrequency;
			var maskParts = mask.split("");
			for (var maskIndex = 0; maskIndex < maskParts.length; maskIndex++) {	
				maskPart = maskParts[maskIndex];
				if (maskPart == '?') {
					len--;
					hasPartialPosition = true;
					partialPosition = maskIndex;
				} else if (maskPart == '*') {
					// Invalid syntax, ignore...
				} else if (defs[maskPart]) {
					maskPartFrequency = 'single';
					if (maskIndex < maskParts.length - 1) {
						if (maskParts[maskIndex + 1] === '*') {
							maskPartFrequency = 'multiple';
							len--;
						}
					}
					tests.push({ expr: new RegExp(defs[maskPart]), freq: maskPartFrequency });
					if (firstNonMaskPos === null) {
						firstNonMaskPos = tests.length - 1;
					}
					if(!hasPartialPosition || maskIndex < partialPosition){
						lastRequiredNonMaskPos = tests.length - 1;
					}
					if (maskPartFrequency === "multiple") {
						maskIndex += 1;
					}
				} else {
					tests.push(null);
				}
			}

			return this.trigger("unmask").each(function() {
				var input = $(this),
					buffer = mask.split("")
						.filter(function (c) { return c !== '?' && c !== '*'; })
						.map(function(c, i) {
							return defs[c] ? getPlaceholder(i) : c;
						}),
					defaultBuffer = buffer.join(''),
					focusText = input.val();

				function tryFireCompleted(){
					if (!settings.completed) {
						return;
					}

					for (var i = firstNonMaskPos; i <= lastRequiredNonMaskPos; i++) {
						if (tests[i] && buffer[i] === getPlaceholder(i)) {
							return;
						}
					}
					settings.completed.call(input);
				}

				function getPlaceholder(i){
					if(i < settings.placeholder.length)
						return settings.placeholder.charAt(i);
					return settings.placeholder.charAt(0);
				}

				function seekNext(pos) {
					while (++pos < len && !(tests[pos] || (pos >= tests.length && tests[tests.length - 1].freq === "multiple")));
					return pos;
				}

				function seekPrev(pos) {
					while (--pos >= 0 && !tests[pos] && !(pos >= tests.length && tests[tests.length - 1].freq === "multiple"));
					return pos;
				}

				function shiftL(begin,end) {
					var i,
						j,
						maxLen = tests[tests.length - 1].freq === "multiple" ? buffer.length : len,
						test;

					if (begin<0) {
						return;
					}

					for (i = begin, j = seekNext(end); i < maxLen; i++) {
						var test = tests[i];
						if (i >= tests.length) {
							if (tests[tests.length - 1].freq === "multiple") {
								test = tests[tests.length - 1];
							}
						}
						if (test) {
							if ((j < maxLen || test.freq === "multiple") && test.expr.test(buffer[j])) {
								buffer[i] = buffer[j];
								buffer[j] = getPlaceholder(j);
							} else {
								break;
							}

							j = seekNext(j);
						}
					}
					if (buffer.join('') === defaultBuffer) {
						// Shifted left (ex: backspace) to default buffer (ex: no content), so write empty string
						if (input.val()) writeInputValue("");
						clearBuffer(0, maxLen);
					} else {
						writeBuffer();
					}
					input.caret(Math.max(firstNonMaskPos, begin));
				}

				function shiftR(pos) {
					var i,
						c,
						j,
						t,
						maxLen = tests[tests.length - 1].freq === "multiple" ? buffer.length : len,
						test;

					for (i = pos, c = getPlaceholder(pos); i <= maxLen; i++) {
						var test = tests[i];
						if (i >= tests.length) {
							if (tests[tests.length - 1].freq === "multiple") {
								test = tests[tests.length - 1];
							}
						}
						if (test) {
							j = seekNext(i);
							t = buffer[i];
							buffer[i] = c;
							if ((j <= maxLen || test.freq === "multiple") && test.expr.test(t)) {
								c = t;
							} else {
								break;
							}
						}
					}
				}

				function androidInputEvent(e) {
					var curVal = input.val();
					var pos = input.caret();
					if (oldVal && oldVal.length && oldVal.length > curVal.length ) {
						// a deletion or backspace happened
						checkVal(true);
						while (pos.begin > 0 && !tests[pos.begin-1])
							pos.begin--;
						if (pos.begin === 0)
						{
							while (pos.begin < firstNonMaskPos && !tests[pos.begin])
								pos.begin++;
						}
						input.caret(pos.begin,pos.begin);
					} else {
						var inputIndex = pos.begin - 1;
						var pos2 = checkVal(true, inputIndex);
						var lastEnteredValue = curVal.charAt(inputIndex);
						if(!tests[inputIndex]){
							inputIndex++;
							if(tests[inputIndex] && tests[inputIndex].expr.test(lastEnteredValue)){
								inputIndex++;
							}
						}else{
							if(tests[inputIndex].expr.test(lastEnteredValue)){
								inputIndex++;
							}
						}
						input.caret(inputIndex,inputIndex);
					}
					tryFireCompleted();
				}

				function blurEvent(e) {
					checkVal();

					if (input.val() != focusText) {
						simulateChangeEvent();
					}
				}

				function keydownEvent(e) {
					if (input.prop("readonly")){
						return;
					}

					var k = e.which || e.keyCode,
						pos,
						begin,
						end;
						oldVal = input.val();
					//backspace, delete, and escape get special treatment
					if (k === 8 || k === 46 || (iPhone && k === 127)) {
						pos = input.caret();
						begin = pos.begin;
						end = pos.end;

						if (end - begin === 0) {
							begin=k!==46?seekPrev(begin):(end=seekNext(begin-1));
							end=k===46?seekNext(end):end;
						}
						clearBuffer(begin, end);
						shiftL(begin, end - 1);
						e.preventDefault();
					} else if( k === 13 ) { // enter
						blurEvent.call(this, e);
					} else if (k === 27) { // escape
						writeInputValue(focusText);
						input.caret(0, checkVal());
						e.preventDefault();
					}
				}

				function keypressEvent(e) {
					if (input.prop("readonly")){
						return;
					}

					var k = e.which || e.keyCode,
						pos = input.caret(),
						p,
						c,
						next,
						test;

					if (e.ctrlKey || e.altKey || e.metaKey || k < 32) {//Ignore
						return;
					} else if ( k && k !== 13 ) {
						if (pos.end - pos.begin !== 0){
							clearBuffer(pos.begin, pos.end);
							shiftL(pos.begin, pos.end-1);
						}

						p = seekNext(pos.begin - 1);
						c = String.fromCharCode(k);
						test = tests[p];
						if (!test) {
							for (var t = p; t >= 0; t--) {
								test = tests[t];
								if (test) {
									if (test.freq !== "multiple") {
										test = null;
									}
									break;
								}
							}
						}
						if (test && test.expr.test(c)) {
							shiftR(p);

							buffer[p] = c;
							writeBuffer(p);
							next = seekNext(p);

							if(android){
								//Path for CSP Violation on FireFox OS 1.1
								var proxy = function() {
									$.proxy($.fn.caret,input,next)();
								};

								setTimeout(proxy,0);
							}else{
								input.caret(next);
							}
							if(pos.begin <= lastRequiredNonMaskPos){
								 tryFireCompleted();
							 }
						} else if (p > pos.begin & !tests[pos.begin] && c === buffer[pos.begin]) {
							// The character that was typed is a placeholder character that matches the buffer,
							// so attempt to output the buffer (including the typed placeholder character) to that point
							checkVal(false, pos.begin);
						}
						e.preventDefault();
					}
				}

				function clearBuffer(start, end) {
					var i,
						maxLen = tests[tests.length - 1].freq === "multiple" ? buffer.length : len;
					for (i = start; i < end && i < maxLen; i++) {
						if (tests[i]) {
							buffer[i] = getPlaceholder(i);
						} else if (i >= tests.length && tests[tests.length - 1].freq === "multiple") {
							buffer.splice(i, 1);
						}
					}
				}

				function writeInputValue(val) {
					input.val(val);
				}

				function writeBuffer(lastTypedIndex) {
					var test = buffer.join(''),
						str = "",
						nonMatchedBuffer = "",
						lastMatch = -1,
						lastNonMatch = -1,
						maxLen = tests[tests.length - 1].freq === "multiple" ? test.length : len,
						ph,
						i,
						c,
						pos;

					for (i = 0, pos = 0; i < maxLen; i++) {
						ph = getPlaceholder(i);
						if (lastNonMatch >= 0) {
							c = test.charAt(pos - 1);
							if (c === ph) {
								nonMatchedBuffer += ph;
							} else {
								if (nonMatchedBuffer) {
									str += nonMatchedBuffer;
									nonMatchedBuffer = "";
								}

								// Didn't match, but is not a placeholder, so write to output
								str += c;
							}
						} else {
							var t = tests[i];
							if (i >= tests.length) {
								if (tests[tests.length - 1].freq === "multiple") {
									t = tests[tests.length - 1];
								}
							}
							pos += 1;
							if (t) {
								c = test.charAt(pos - 1);
								if (c === ph) {
									if (lastNonMatch < 0) {
										lastNonMatch = i;
									}
								} else if (t.expr.test(c)) {
									lastMatch = i;
									str += c;
								} else {
									lastNonMatch = i;
									if (c === ph) {
										nonMatchedBuffer += ph;
									} else {
										// Didn't match, but not a placeholder, so write to output
										str += c;
									}
								}
							} else {
								c = test.charAt(pos);
								if (buffer[i] === c) {
									pos++;
								}
								str += buffer[i];
							}
						}
					}

					if (hasPartialPosition && lastNonMatch >= partialPosition && lastMatch < partialPosition) {
						// The value ends with non-matched characters after the partial position (i.e. non-numeric symbols) so discard them
						if (typeof lastTypedIndex === "number" && lastMatch < lastTypedIndex && lastNonMatch > lastTypedIndex) {
							// The last typed character is not a matched alphanumeric character, but is a mask character that precedes the next unmatched character, so output the mask character
							str = str.substring(0, lastTypedIndex + 1);
						} else {
							str = str.substring(0, partialPosition);
						}
					}

					writeInputValue(str);
				}

				function simulateChangeEvent() {
					// Call `$simulateMutationEvent` to ensure that MSAJAX bindings
					// know that the value has changed, and can respond.
					input.each(function () {
						$simulateMutationEvent(this, "change", false, true);
					});

					// We must call jQuery change afterwards, since we use jQuery change to
					// drive calling`updateValidation`, and we need bindings to update first.
					input.change();
				}

				function checkVal(allow, lastTypedIndex) {
					//try to place characters where they belong
					var test = input.val(),
						lastMatch = -1,
						maxLen = tests[tests.length - 1].freq === "multiple" ? len + 1 : len,
						isMultiMatch = false,
						i,
						c,
						pos;

					for (i = 0, pos = 0; i < maxLen; i++) {
						var t = tests[i];
						if (i >= tests.length) {
							if (tests[tests.length - 1].freq === "multiple") {
								t = tests[tests.length - 1];
								isMultiMatch = true;
							}
						}
						if (t) {
							buffer[i] = getPlaceholder(i);
							while (pos++ < test.length) {
								t = tests[i];
								if (i >= tests.length) {
									if (tests[tests.length - 1].freq === "multiple") {
										t = tests[tests.length - 1];
										isMultiMatch = true;
									}
								}
								c = test.charAt(pos - 1);
								if (t.expr.test(c)) {
									buffer[i] = c;
									lastMatch = i;
									if (isMultiMatch && i === maxLen - 1) {
										maxLen += 1;
									}
									break;
								}
							}
							if (pos > test.length) {
								clearBuffer(i + 1, maxLen);
								break;
							}
						} else {
							if (buffer[i] === test.charAt(pos)) {
								pos++;
							}
							if( i < partialPosition){
								lastMatch = i;
							}
						}
					}
					if (i < buffer.length) {
						// The actual value is shorter than the buffer (ex: pasting a shorter value),
						// so, clear out the buffer past the last position
						clearBuffer(i, buffer.length);
					}
					if (allow) {
						writeBuffer(lastTypedIndex);
					} else if (hasPartialPosition && lastMatch + 1 < partialPosition) {
						if (settings.autoclear || buffer.join('') === defaultBuffer) {
							// Invalid value. Remove it and replace it with the
							// mask, which is the default behavior.
							if (input.val()) writeInputValue("");
							clearBuffer(0, maxLen);
						} else {
							// Invalid value, but we opt to show the value to the
							// user and allow them to correct their mistake.
							writeBuffer(lastTypedIndex);
						}
					} else {
						writeBuffer(lastTypedIndex);
						var inputVal = input.val();
						var writeToIndex = lastMatch;
						if (typeof lastTypedIndex === "number" && lastTypedIndex > lastMatch & !tests[lastTypedIndex] && lastTypedIndex < inputVal.length && inputVal[lastTypedIndex] === buffer[lastTypedIndex]) {
							// Output trailing placeholder character if it was the last character typed
							writeToIndex = lastTypedIndex;
						}
						// // Detect the situation where the input will be truncated
						//if (input.val() !== input.val().substring(0, writeToIndex + 1)) {
						//	// debugger;
						//}
						writeInputValue(input.val().substring(0, writeToIndex + 1));
					}
					return (hasPartialPosition ? (lastMatch >= 0 ? lastMatch + 1 : i) : firstNonMaskPos);
				}

				input.data($.mask.dataName,function(){
					return $.map(buffer, function(c, i) {
						return tests[i]&&c!=getPlaceholder(i) ? c : null;
					}).join('');
				});


				input
					.one("unmask", function() {
						input
							.off(".mask")
							.removeData($.mask.dataName);
					})
					.on("focus.mask", function() {
						if (input.prop("readonly")){
							return;
						}

						clearTimeout(caretTimeoutId);

						var pos = input.caret();

						focusText = input.val();

						var pos2 = checkVal();

						caretTimeoutId = setTimeout(function(){
							if(input.get(0) !== document.activeElement){
								return;
							}

							// Writing the buffer here results in inconsistent behavior in
							// terms of whether or not "placeholder" text is shown
							//writeBuffer();

							var inputText = input.val();

							if (pos2 == mask.replace("?","").length) {
								// Appears to be detecting the situation where the entire mask has been matched,
								// and select the entire text, presumably because the user can't type any more text?
								input.caret(0, pos2);
							} else if (pos.begin === 0 && pos.end === focusText.length) {
								// If the entire text was selected, then re-select accounting
								// for the possibility of manipulation of the value
								input.caret(0, inputText.length);
							} else if (inputText !== focusText) {
								// Otherwise, if the text was modified, then move the cursor to the last appropriate input location (???)
								input.caret(pos2);
							}
						}, 10);
					})
					.on("blur.mask", blurEvent)
					.on("keydown.mask", keydownEvent)
					.on("keypress.mask", keypressEvent)
					.on("input.mask paste.mask", function() {
						if (input.prop("readonly")){
							return;
						}

						setTimeout(function() {
							var pos=checkVal(true);
							input.caret(pos);
							tryFireCompleted();
						}, 0);
					});
					if (chrome && android)
					{
						input
							.off('input.mask')
							.on('input.mask', androidInputEvent);
					}
					if (settings.autoinit) {
						checkVal(); //Perform initial check for existing values
					}
			});
		}
	});
})(jQuery);
})();
;(function() { if (Cognito.config.scripts.indexOf('cognito-nobots') >= 0) return; else Cognito.config.scripts.push('cognito-nobots');Cognito.ready('detect-bots', function ($) {
    function DetectBots(challenge, timeout, immediate) {
        // only allow this function to be called once, presumably by the server-generated html to prevent immediate validation from a 3rd party.
        // this also makes it a little harder for other javascript to detect the bot detection.
        window.DetectBots = null;

        function encode(string) {

            function RotateLeft(lValue, iShiftBits) {
                return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
            }

            function AddUnsigned(lX, lY) {
                var lX4, lY4, lX8, lY8, lResult;
                lX8 = (lX & 0x80000000);
                lY8 = (lY & 0x80000000);
                lX4 = (lX & 0x40000000);
                lY4 = (lY & 0x40000000);
                lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
                if (lX4 & lY4) {
                    return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
                }
                if (lX4 | lY4) {
                    if (lResult & 0x40000000) {
                        return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
                    } else {
                        return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
                    }
                } else {
                    return (lResult ^ lX8 ^ lY8);
                }
            }

            function F(x, y, z) { return (x & y) | ((~x) & z); }
            function G(x, y, z) { return (x & z) | (y & (~z)); }
            function H(x, y, z) { return (x ^ y ^ z); }
            function I(x, y, z) { return (y ^ (x | (~z))); }

            function FF(a, b, c, d, x, s, ac) {
                a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
                return AddUnsigned(RotateLeft(a, s), b);
            };

            function GG(a, b, c, d, x, s, ac) {
                a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
                return AddUnsigned(RotateLeft(a, s), b);
            };

            function HH(a, b, c, d, x, s, ac) {
                a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
                return AddUnsigned(RotateLeft(a, s), b);
            };

            function II(a, b, c, d, x, s, ac) {
                a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
                return AddUnsigned(RotateLeft(a, s), b);
            };

            function ConvertToWordArray(string) {
                var lWordCount;
                var lMessageLength = string.length;
                var lNumberOfWords_temp1 = lMessageLength + 8;
                var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
                var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
                var lWordArray = Array(lNumberOfWords - 1);
                var lBytePosition = 0;
                var lByteCount = 0;
                while (lByteCount < lMessageLength) {
                    lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                    lBytePosition = (lByteCount % 4) * 8;
                    lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) << lBytePosition));
                    lByteCount++;
                }
                lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                lBytePosition = (lByteCount % 4) * 8;
                lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
                lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
                lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
                return lWordArray;
            };

            function WordToHex(lValue) {
                var WordToHexValue = "", WordToHexValue_temp = "", lByte, lCount;
                for (lCount = 0; lCount <= 3; lCount++) {
                    lByte = (lValue >>> (lCount * 8)) & 255;
                    WordToHexValue_temp = "0" + lByte.toString(16);
                    WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
                }
                return WordToHexValue;
            };

            function Utf8Encode(string) {
                string = string.replace(/\r\n/g, "\n");
                var utftext = "";

                for (var n = 0; n < string.length; n++) {

                    var c = string.charCodeAt(n);

                    if (c < 128) {
                        utftext += String.fromCharCode(c);
                    }
                    else if ((c > 127) && (c < 2048)) {
                        utftext += String.fromCharCode((c >> 6) | 192);
                        utftext += String.fromCharCode((c & 63) | 128);
                    }
                    else {
                        utftext += String.fromCharCode((c >> 12) | 224);
                        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                        utftext += String.fromCharCode((c & 63) | 128);
                    }

                }

                return utftext;
            };

            var x = Array();
            var k, AA, BB, CC, DD, a, b, c, d;
            var S11 = 7, S12 = 12, S13 = 17, S14 = 22;
            var S21 = 5, S22 = 9, S23 = 14, S24 = 20;
            var S31 = 4, S32 = 11, S33 = 16, S34 = 23;
            var S41 = 6, S42 = 10, S43 = 15, S44 = 21;

            string = Utf8Encode(string);

            x = ConvertToWordArray(string);

            a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;

            for (k = 0; k < x.length; k += 16) {
                AA = a; BB = b; CC = c; DD = d;
                a = FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
                d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
                c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
                b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
                a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
                d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
                c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
                b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
                a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
                d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
                c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
                b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
                a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
                d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
                c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
                b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
                a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
                d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
                c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
                b = GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
                a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
                d = GG(d, a, b, c, x[k + 10], S22, 0x2441453);
                c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
                b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
                a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
                d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
                c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
                b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
                a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
                d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
                c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
                b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
                a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
                d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
                c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
                b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
                a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
                d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
                c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
                b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
                a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
                d = HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
                c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
                b = HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
                a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
                d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
                c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
                b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
                a = II(a, b, c, d, x[k + 0], S41, 0xF4292244);
                d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
                c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
                b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
                a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
                d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
                c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
                b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
                a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
                d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
                c = II(c, d, a, b, x[k + 6], S43, 0xA3014314);
                b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
                a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
                d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
                c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
                b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
                a = AddUnsigned(a, AA);
                b = AddUnsigned(b, BB);
                c = AddUnsigned(c, CC);
                d = AddUnsigned(d, DD);
            }

            var temp = WordToHex(a) + WordToHex(b) + WordToHex(c) + WordToHex(d);

            return temp.toLowerCase();
        }

        function validate() {
            $('<input>').attr('type', 'hidden').appendTo('form').attr({
                name: "NoBots",
                id: "c-nobots",
                value: challenge + "|" + encode(challenge)
            });
        }

        var events = ['mousedown', 'keydown'];

        function userDetected() {
            validate();
            for (var i = 0; i < events.length; ++i)
                $('body').off(events[i], userDetected);
        }

        if (immediate) {
            validate();
        }
        else {
            for (var i = 0; i < events.length; ++i)
                $('body').on(events[i], userDetected);

            if (timeout > 0) {
                window.setTimeout(function () {
                    for (var i = 0; i < events.length; ++i) {
                        $('body').unbind(events[i], userDetected);
                        $('body').bind(events[i], function () {
                            alert('The page has expired and must be reloaded before you can continue.  Click OK to reload it.');
                            $('body').hide();
                            window.location.href = window.location.href;
                        });
                    }
                }, timeout);
            }
        }
    }
    window.DetectBots = DetectBots;
});
})();
;(function() { if (Cognito.config.scripts.indexOf('jquery.color') >= 0) return; else Cognito.config.scripts.push('jquery.color');/*!
 * jQuery Color Animations v2.1.0
 * http://jquery.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Fri Aug 24 12:02:24 2012 -0500
 */
(function(jQuery, undefined) {

	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

	// plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
	// a set of RE's that can match strings and generate color tuples.
	stringParsers = [{
		re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
		parse: function(execResult) {
			return [
				execResult[1],
				execResult[2],
				execResult[3],
				execResult[4]
			];
		}
	}, {
		re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
		parse: function(execResult) {
			return [
				execResult[1] * 2.55,
				execResult[2] * 2.55,
				execResult[3] * 2.55,
				execResult[4]
			];
		}
	}, {
		// this regex ignores A-F because it's compared against an already lowercased string
		re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
		parse: function(execResult) {
			return [
				parseInt(execResult[1], 16),
				parseInt(execResult[2], 16),
				parseInt(execResult[3], 16)
			];
		}
	}, {
		// this regex ignores A-F because it's compared against an already lowercased string
		re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
		parse: function(execResult) {
			return [
				parseInt(execResult[1] + execResult[1], 16),
				parseInt(execResult[2] + execResult[2], 16),
				parseInt(execResult[3] + execResult[3], 16)
			];
		}
	}, {
		re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
		space: "hsla",
		parse: function(execResult) {
			return [
				execResult[1],
				execResult[2] / 100,
				execResult[3] / 100,
				execResult[4]
			];
		}
	}],

	// jQuery.Color( )
	color = jQuery.Color = function(color, green, blue, alpha) {
		return new jQuery.Color.fn.parse(color, green, blue, alpha);
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: "byte"
				},
				green: {
					idx: 1,
					type: "byte"
				},
				blue: {
					idx: 2,
					type: "byte"
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: "degrees"
				},
				saturation: {
					idx: 1,
					type: "percent"
				},
				lightness: {
					idx: 2,
					type: "percent"
				}
			}
		}
	},
	propTypes = {
		"byte": {
			floor: true,
			max: 255
		},
		"percent": {
			max: 1
		},
		"degrees": {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// element for support tests
	supportElem = jQuery("<p>")[0],

	// colors = jQuery.Color.names
	colors,

	// local aliases of functions called often
	each = jQuery.each;

	// determine rgba support immediately
	supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
	support.rgba = supportElem.style.backgroundColor.indexOf("rgba") > -1;

	// define cache name and alpha properties
	// for rgba and hsla spaces
	each(spaces, function(spaceName, space) {
		space.cache = "_" + spaceName;
		space.props.alpha = {
			idx: 3,
			type: "percent",
			def: 1
		};
	});

	function clamp(value, prop, allowEmpty) {
		var type = propTypes[prop.type] || {};

		if (value == null) {
			return (allowEmpty || !prop.def) ? null : prop.def;
		}

		// ~~ is an short way of doing floor for positive numbers
		value = type.floor ? ~~value : parseFloat(value);

		// IE will pass in empty strings as value for alpha,
		// which will hit this case
		if (isNaN(value)) {
			return prop.def;
		}

		if (type.mod) {
			// we add mod before modding to make sure that negatives values
			// get converted properly: -10 -> 350
			return (value + type.mod) % type.mod;
		}

		// for now all property types without mod have min and max
		return 0 > value ? 0 : type.max < value ? type.max : value;
	}

	function stringParse(string) {
		var inst = color(),
			rgba = inst._rgba = [];

		string = string.toLowerCase();

		each(stringParsers, function(i, parser) {
			var parsed,
				match = parser.re.exec(string),
				values = match && parser.parse(match),
				spaceName = parser.space || "rgba";

			if (values) {
				parsed = inst[spaceName](values);

				// if this was an rgba parse the assignment might happen twice
				// oh well....
				inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
				rgba = inst._rgba = parsed._rgba;

				// exit each( stringParsers ) here because we matched
				return false;
			}
		});

		// Found a stringParser that handled it
		if (rgba.length) {

			// if this came from a parsed string, force "transparent" when alpha is 0
			// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
			if (rgba.join() === "0,0,0,0") {
				jQuery.extend(rgba, colors.transparent);
			}
			return inst;
		}

		// named colors
		return colors[string];
	}

	color.fn = jQuery.extend(color.prototype, {
		parse: function(red, green, blue, alpha) {
			if (red === undefined) {
				this._rgba = [null, null, null, null];
				return this;
			}
			if (red.jquery || red.nodeType) {
				red = jQuery(red).css(green);
				green = undefined;
			}

			var inst = this,
				type = jQuery.type(red),
				rgba = this._rgba = [],
				source;

			// more than 1 argument specified - assume ( red, green, blue, alpha )
			if (green !== undefined) {
				red = [red, green, blue, alpha];
				type = "array";
			}

			if (type === "string") {
				return this.parse(stringParse(red) || colors._default);
			}

			if (type === "array") {
				each(spaces.rgba.props, function(key, prop) {
					rgba[prop.idx] = clamp(red[prop.idx], prop);
				});
				return this;
			}

			if (type === "object") {
				if (red instanceof color) {
					each(spaces, function(spaceName, space) {
						if (red[space.cache]) {
							inst[space.cache] = red[space.cache].slice();
						}
					});
				} else {
					each(spaces, function(spaceName, space) {
						var cache = space.cache;
						each(space.props, function(key, prop) {

							// if the cache doesn't exist, and we know how to convert
							if (!inst[cache] && space.to) {

								// if the value was null, we don't need to copy it
								// if the key was alpha, we don't need to copy it either
								if (key === "alpha" || red[key] == null) {
									return;
								}
								inst[cache] = space.to(inst._rgba);
							}

							// this is the only case where we allow nulls for ALL properties.
							// call clamp with alwaysAllowEmpty
							inst[cache][prop.idx] = clamp(red[key], prop, true);
						});

						// everything defined but alpha?
						if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {
							// use the default of 1
							inst[cache][3] = 1;
							if (space.from) {
								inst._rgba = space.from(inst[cache]);
							}
						}
					});
				}
				return this;
			}
		},
		is: function(compare) {
			var is = color(compare),
				same = true,
				inst = this;

			each(spaces, function(_, space) {
				var localCache,
					isCache = is[space.cache];
				if (isCache) {
					localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];
					each(space.props, function(_, prop) {
						if (isCache[prop.idx] != null) {
							same = (isCache[prop.idx] === localCache[prop.idx]);
							return same;
						}
					});
				}
				return same;
			});
			return same;
		},
		_space: function() {
			var used = [],
				inst = this;
			each(spaces, function(spaceName, space) {
				if (inst[space.cache]) {
					used.push(spaceName);
				}
			});
			return used.pop();
		},
		transition: function(other, distance) {
			var end = color(other),
				spaceName = end._space(),
				space = spaces[spaceName],
				startColor = this.alpha() === 0 ? color("transparent") : this,
				start = startColor[space.cache] || space.to(startColor._rgba),
				result = start.slice();

			end = end[space.cache];
			each(space.props, function(key, prop) {
				var index = prop.idx,
					startValue = start[index],
					endValue = end[index],
					type = propTypes[prop.type] || {};

				// if null, don't override start value
				if (endValue === null) {
					return;
				}
				// if null - use end
				if (startValue === null) {
					result[index] = endValue;
				} else {
					if (type.mod) {
						if (endValue - startValue > type.mod / 2) {
							startValue += type.mod;
						} else if (startValue - endValue > type.mod / 2) {
							startValue -= type.mod;
						}
					}
					result[index] = clamp((endValue - startValue) * distance + startValue, prop);
				}
			});
			return this[spaceName](result);
		},
		blend: function(opaque) {
			// if we are already opaque - return ourself
			if (this._rgba[3] === 1) {
				return this;
			}

			var rgb = this._rgba.slice(),
				a = rgb.pop(),
				blend = color(opaque)._rgba;

			return color(jQuery.map(rgb, function(v, i) {
				return (1 - a) * blend[i] + a * v;
			}));
		},
		toRgbaString: function() {
			var prefix = "rgba(",
				rgba = jQuery.map(this._rgba, function(v, i) {
					return v == null ? (i > 2 ? 1 : 0) : v;
				});

			if (rgba[3] === 1) {
				rgba.pop();
				prefix = "rgb(";
			}

			return prefix + rgba.join() + ")";
		},
		toHslaString: function() {
			var prefix = "hsla(",
				hsla = jQuery.map(this.hsla(), function(v, i) {
					if (v == null) {
						v = i > 2 ? 1 : 0;
					}

					// catch 1 and 2
					if (i && i < 3) {
						v = Math.round(v * 100) + "%";
					}
					return v;
				});

			if (hsla[3] === 1) {
				hsla.pop();
				prefix = "hsl(";
			}
			return prefix + hsla.join() + ")";
		},
		toHexString: function(includeAlpha) {
			var rgba = this._rgba.slice(),
				alpha = rgba.pop();

			if (includeAlpha) {
				rgba.push(~~(alpha * 255));
			}

			return "#" + jQuery.map(rgba, function(v, i) {

				// default to 0 when nulls exist
				v = (v || 0).toString(16);
				return v.length === 1 ? "0" + v : v;
			}).join("");
		},
		toString: function() {
			return this._rgba[3] === 0 ? "transparent" : this.toRgbaString();
		},
		isLightColor: function () {
			if (!this._rgba)
				return true;

			try {
				return Math.sqrt((this._rgba[0] * this._rgba[0] * 0.299) + (this._rgba[1] * this._rgba[1] * 0.587) + (this._rgba[2] * this._rgba[2] * 0.114)) >= 170;
			} catch (err) { return true; }
		}
	});
	color.fn.parse.prototype = color.fn;

	// hsla conversions adapted from:
	// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

	function hue2rgb(p, q, h) {
		h = (h + 1) % 1;
		if (h * 6 < 1) {
			return p + (q - p) * h * 6;
		}
		if (h * 2 < 1) {
			return q;
		}
		if (h * 3 < 2) {
			return p + (q - p) * ((2 / 3) - h) * 6;
		}
		return p;
	}

	spaces.hsla.to = function(rgba) {
		if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
			return [null, null, null, rgba[3]];
		}
		var r = rgba[0] / 255,
			g = rgba[1] / 255,
			b = rgba[2] / 255,
			a = rgba[3],
			max = Math.max(r, g, b),
			min = Math.min(r, g, b),
			diff = max - min,
			add = max + min,
			l = add * 0.5,
			h, s;

		if (min === max) {
			h = 0;
		} else if (r === max) {
			h = (60 * (g - b) / diff) + 360;
		} else if (g === max) {
			h = (60 * (b - r) / diff) + 120;
		} else {
			h = (60 * (r - g) / diff) + 240;
		}

		if (l === 0 || l === 1) {
			s = l;
		} else if (l <= 0.5) {
			s = diff / add;
		} else {
			s = diff / (2 - add);
		}
		return [Math.round(h) % 360, s, l, a == null ? 1 : a];
	};

	spaces.hsla.from = function(hsla) {
		if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
			return [null, null, null, hsla[3]];
		}
		var h = hsla[0] / 360,
			s = hsla[1],
			l = hsla[2],
			a = hsla[3],
			q = l <= 0.5 ? l * (1 + s) : l + s - l * s,
			p = 2 * l - q,
			r, g, b;

		return [
			Math.round(hue2rgb(p, q, h + (1 / 3)) * 255),
			Math.round(hue2rgb(p, q, h) * 255),
			Math.round(hue2rgb(p, q, h - (1 / 3)) * 255),
			a
		];
	};

	each(spaces, function(spaceName, space) {
		var props = space.props,
			cache = space.cache,
			to = space.to,
			from = space.from;

		// makes rgba() and hsla()
		color.fn[spaceName] = function(value) {

			// generate a cache for this space if it doesn't exist
			if (to && !this[cache]) {
				this[cache] = to(this._rgba);
			}
			if (value === undefined) {
				return this[cache].slice();
			}

			var ret,
				type = jQuery.type(value),
				arr = (type === "array" || type === "object") ? value : arguments,
				local = this[cache].slice();

			each(props, function(key, prop) {
				var val = arr[type === "object" ? key : prop.idx];
				if (val == null) {
					val = local[prop.idx];
				}
				local[prop.idx] = clamp(val, prop);
			});

			if (from) {
				ret = color(from(local));
				ret[cache] = local;
				return ret;
			} else {
				return color(local);
			}
		};

		// makes red() green() blue() alpha() hue() saturation() lightness()
		each(props, function(key, prop) {
			// alpha is included in more than one space
			if (color.fn[key]) {
				return;
			}
			color.fn[key] = function(value) {
				var vtype = jQuery.type(value),
					fn = (key === "alpha" ? (this._hsla ? "hsla" : "rgba") : spaceName),
					local = this[fn](),
					cur = local[prop.idx],
					match;

				if (vtype === "undefined") {
					return cur;
				}

				if (vtype === "function") {
					value = value.call(this, cur);
					vtype = jQuery.type(value);
				}
				if (value == null && prop.empty) {
					return this;
				}
				if (vtype === "string") {
					match = rplusequals.exec(value);
					if (match) {
						value = cur + parseFloat(match[2]) * (match[1] === "+" ? 1 : -1);
					}
				}
				local[prop.idx] = value;
				return this[fn](local);
			};
		});
	});

	// add cssHook and .fx.step function for each named hook.
	// accept a space separated string of properties
	color.hook = function(hook) {
		var hooks = hook.split(" ");
		each(hooks, function(i, hook) {
			jQuery.cssHooks[hook] = {
				set: function(elem, value) {
					var parsed, curElem,
						backgroundColor = "";

					if (jQuery.type(value) !== "string" || (parsed = stringParse(value))) {
						value = color(parsed || value);
						if (!support.rgba && value._rgba[3] !== 1) {
							curElem = hook === "backgroundColor" ? elem.parentNode : elem;
							while (
								(backgroundColor === "" || backgroundColor === "transparent") &&
								curElem && curElem.style
							) {
								try {
									backgroundColor = jQuery.css(curElem, "backgroundColor");
									curElem = curElem.parentNode;
								} catch (e) {
								}
							}

							value = value.blend(backgroundColor && backgroundColor !== "transparent" ?
								backgroundColor :
								"_default");
						}

						value = value.toRgbaString();
					}
					try {
						elem.style[hook] = value;
					} catch (value) {
						// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
					}
				}
			};
			jQuery.fx.step[hook] = function(fx) {
				if (!fx.colorInit) {
					fx.start = color(fx.elem, hook);
					fx.end = color(fx.end);
					fx.colorInit = true;
				}
				jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
			};
		});

	};

	color.hook(stepHooks);

	jQuery.cssHooks.borderColor = {
		expand: function(value) {
			var expanded = {};

			each(["Top", "Right", "Bottom", "Left"], function(i, part) {
				expanded["border" + part + "Color"] = value;
			});
			return expanded;
		}
	};

	// Basic color names only.
	// Usage of any of the other color names requires adding yourself or including
	// jquery.color.svg-names.js.
	colors = jQuery.Color.names = {
		// 4.1. Basic color keywords
		aqua: "#00ffff",
		black: "#000000",
		blue: "#0000ff",
		fuchsia: "#ff00ff",
		gray: "#808080",
		green: "#008000",
		lime: "#00ff00",
		maroon: "#800000",
		navy: "#000080",
		olive: "#808000",
		purple: "#800080",
		red: "#ff0000",
		silver: "#c0c0c0",
		teal: "#008080",
		white: "#ffffff",
		yellow: "#ffff00",

		// 4.2.3. ‘transparent’ color keyword
		transparent: [null, null, null, 0],

		_default: "#ffffff"
	};

})(jQuery);
})();
;(function() { if (Cognito.config.scripts.indexOf('embed-seamless') >= 0) return; else Cognito.config.scripts.push('embed-seamless');(function ($) {
	Cognito.getBackgroundColor = function getBackgroundColor(element) {
		try {
			if (element == null || element.length == 0 || element[0] == document)
				return ExoJQuery.Color("FFF");

			var color = ExoJQuery.Color(element[0], "background-color");
			switch (color.alpha()) {
				case 0: return getBackgroundColor(element.parent());
				case 1: return color;
				default: return color.blend(getBackgroundColor(element.parent()));
			}
		} catch (err) {
			return null;
		}
	}
})(ExoJQuery || $);
})();

});
